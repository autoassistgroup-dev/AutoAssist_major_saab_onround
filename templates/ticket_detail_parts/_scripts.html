                <!-- Template data -->
                <script type="application/json" id="attachments-data">
        {{ (attachments|default([]))|tojson|safe }}
    </script>

                <script type="application/json" id="vehicle-data">
        {
            "vehicle_registration": {{ vehicle_registration|default('')|tojson }},
            "service_date": {{ service_date|default('')|tojson }},
            "claim_date": {{ claim_date|default('')|tojson }},
            "type_of_claim": {{ type_of_claim|default('')|tojson }},
            "vhc_link": {{ vhc_link|default('')|tojson }},
            "days_between_service_claim": {{ days_between_service_claim|default('')|tojson }},
            "advisories_followed": {{ 'true' if advisories_followed else 'false' }},
            "within_warranty": {{ 'true' if within_warranty else 'false' }},
            "new_fault_codes": {{ 'true' if new_fault_codes else 'false' }},
            "dpf_light_on": {{ 'true' if dpf_light_on else 'false' }},
            "eml_light_on": {{ 'true' if eml_light_on else 'false' }}
        }
    </script>
                <script>

                    let processedDocuments = new Set(); // Track all processed documents in this session
                    let lastProcessedDocument = null;
                    let lastProcessedTime = 0;

                    // ðŸš€ REMOVED: Old attachment variables - replaced by enhanced system

                    // Notification system
                    function showNotification(message, type = 'success') {
                        const notification = document.getElementById('notification');
                        const notificationMessage = document.getElementById('notification-message');

                        notification.className = `notification ${type}`;
                        notificationMessage.textContent = message;
                        notification.classList.add('show');

                        setTimeout(() => {
                            notification.classList.remove('show');
                        }, 3000);
                    }

                    // Message expansion functionality
                    function expandMessage(elementId) {
                        const element = document.getElementById(elementId);
                        if (!element) return;

                        const isExpanded = element.classList.contains('expanded');

                        // Toggle expanded class
                        element.classList.toggle('expanded');

                        // Toggle truncated class for proper gradient effect
                        // When expanding (was not expanded before), remove truncated
                        // When collapsing (was expanded before), add truncated back
                        if (!isExpanded) {
                            // Expanding: remove truncated class to hide the gradient
                            element.classList.remove('truncated');
                        } else {
                            // Collapsing: add truncated class back for the gradient
                            element.classList.add('truncated');
                        }


                        // Find the button - it might be a child or a sibling
                        let btn = element.querySelector('.expand-btn') || element.querySelector('.read-more-btn');

                        // If not found inside, look for sibling button (for original message)
                        if (!btn && element.nextElementSibling && element.nextElementSibling.classList.contains('read-more-btn')) {
                            btn = element.nextElementSibling;
                        }

                        // Also try the container's button (for original message container structure)
                        if (!btn) {
                            const container = element.closest('.original-message-container') || element.closest('.reply-message-box');
                            if (container) {
                                btn = container.querySelector('.read-more-btn') || container.querySelector('.expand-btn');
                            }
                        }

                        if (btn) {
                            if (element.classList.contains('expanded')) {
                                btn.innerHTML = '<i class="fas fa-chevron-up mr-1"></i> Show Less';
                            } else {
                                btn.innerHTML = '<i class="fas fa-chevron-down mr-1"></i> Read More';
                            }
                        }

                        // Smooth scroll to view the content if expanding
                        if (element.classList.contains('expanded')) {
                            element.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                        }
                    }


                    // Modal control functions - SAFE VERSION: No interference with other buttons
                    function openModal(modalId) {
                        // Close any other open modals first
                        closeAllModals();
                        const modal = document.getElementById(modalId);
                        if (modal) {
                            modal.classList.add('active');
                        }
                    }

                    function closeModal(modalId) {
                        const modal = document.getElementById(modalId);
                        if (modal) {
                            modal.classList.remove('active');

                            // Clean up draft indicator when closing email template modal
                            if (modalId === 'emailTemplateModal') {
                                const draftIndicator = document.getElementById('draftIndicator');
                                if (draftIndicator) {
                                    draftIndicator.remove();
                                }
                            }
                        }
                    }

                    // Close all modals - prevents stuck overlays
                    function closeAllModals() {
                        const activeModals = document.querySelectorAll('.modal-overlay.active');
                        activeModals.forEach(modal => {
                            modal.classList.remove('active');
                        });
                    }

                    // Add escape key to close modals
                    document.addEventListener('keydown', function (event) {
                        if (event.key === 'Escape') {
                            closeAllModals();
                        }
                    });

                    // Close modal when clicking outside - SAFE VERSION
                    document.addEventListener('click', function (event) {
                        if (event.target.classList.contains('modal-overlay') && event.target.classList.contains('active')) {
                            closeModal(event.target.id);
                        }
                    });



                    // Initialize modal cleanup - SAFE: Won't break other buttons
                    function initializeModalCleanup() {
                        // Ensure all modals start closed
                        closeAllModals();

                        // Setup all close buttons to work properly
                        const closeButtons = document.querySelectorAll('[id*="close"], [id*="cancel"]');
                        closeButtons.forEach(button => {
                            // Don't override existing handlers, just ensure modal closes
                            button.addEventListener('click', function (e) {
                                const modal = button.closest('.modal-overlay');
                                if (modal && modal.id) {
                                    closeModal(modal.id);
                                }
                            }, true); // Use capture to ensure it runs
                        });
                    }

                    // Initialize message boxes
                    function initMessageBoxes() {
                        const originalMessage = document.getElementById('originalMessage');
                        if (originalMessage && originalMessage.scrollHeight > originalMessage.clientHeight) {
                            originalMessage.classList.add('truncated');
                        }

                        document.querySelectorAll('.reply-message-box').forEach(box => {
                            if (box.scrollHeight > box.clientHeight) {
                                box.classList.add('truncated');
                            }
                        });
                    }

                    // Notes functionality
                    function loadNotes() {
                        const ticketId = "{{ ticket.ticket_id }}";
                        const notesContainer = document.getElementById('notesContainer');

                        // Get notes from localStorage (replace with API call in production)
                        const notes = JSON.parse(localStorage.getItem(`ticket_notes_${ticketId}`)) || [];

                        if (notes.length === 0) {
                            notesContainer.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">
                            <i class="fas fa-sticky-note"></i>
                        </div>
                        <p>No notes yet. Add your first note!</p>
                    </div>
                `;
                            return;
                        }

                        notesContainer.innerHTML = '';
                        notes.forEach((note, index) => {
                            const noteElement = document.createElement('div');
                            noteElement.className = 'note-card';
                            noteElement.innerHTML = `
                    <div class="note-title">${note.title}</div>
                    <div class="note-content">${note.content}</div>
                    <div class="note-meta">
                        <span>${new Date(note.timestamp).toLocaleString()}</span>
                        <div class="note-actions">
                            <span class="note-action-btn" onclick="editNote(${index})">
                                <i class="fas fa-edit"></i>
                            </span>
                            <span class="note-action-btn" onclick="deleteNote(${index})">
                                <i class="fas fa-trash"></i>
                            </span>
                        </div>
                    </div>
                `;
                            notesContainer.appendChild(noteElement);
                        });
                    }

                    function saveNote() {
                        const title = document.getElementById('noteTitle').value.trim();
                        const content = document.getElementById('noteContent').value.trim();
                        const ticketId = "{{ ticket.ticket_id }}";
                        const noteIndex = document.getElementById('saveNote').getAttribute('data-note-index');

                        if (!title || !content) {
                            showNotification('Please fill in both title and content', 'error');
                            return;
                        }

                        // Get existing notes
                        const notes = JSON.parse(localStorage.getItem(`ticket_notes_${ticketId}`)) || [];

                        if (noteIndex !== null) {
                            // Update existing note
                            notes[noteIndex] = {
                                title,
                                content,
                                timestamp: new Date().toISOString()
                            };
                        } else {
                            // Add new note
                            notes.push({
                                title,
                                content,
                                timestamp: new Date().toISOString()
                            });
                        }

                        // Save back to storage
                        localStorage.setItem(`ticket_notes_${ticketId}`, JSON.stringify(notes));

                        // Refresh notes display
                        loadNotes();

                        // Close modal and show notification
                        closeModal('noteModal');
                        showNotification(noteIndex !== null ? 'Note updated successfully' : 'Note saved successfully');

                        // Clear form
                        document.getElementById('noteTitle').value = '';
                        document.getElementById('noteContent').value = '';
                        document.getElementById('saveNote').removeAttribute('data-note-index');
                    }

                    function editNote(index) {
                        const ticketId = "{{ ticket.ticket_id }}";
                        const notes = JSON.parse(localStorage.getItem(`ticket_notes_${ticketId}`)) || [];

                        if (index >= 0 && index < notes.length) {
                            const note = notes[index];
                            document.getElementById('noteTitle').value = note.title;
                            document.getElementById('noteContent').value = note.content;

                            // Store the index being edited in a data attribute
                            document.getElementById('saveNote').setAttribute('data-note-index', index);

                            openModal('noteModal');
                        }
                    }

                    function deleteNote(index) {
                        if (confirm('Are you sure you want to delete this note?')) {
                            const ticketId = "{{ ticket.ticket_id }}";
                            const notes = JSON.parse(localStorage.getItem(`ticket_notes_${ticketId}`)) || [];

                            if (index >= 0 && index < notes.length) {
                                notes.splice(index, 1);
                                localStorage.setItem(`ticket_notes_${ticketId}`, JSON.stringify(notes));
                                loadNotes();
                                showNotification('Note deleted');
                            }
                        }
                    }

                    // Template functionality
                    function loadTemplates() {
                        const templatesContainer = document.getElementById('templatesContainer');

                        // Get templates from localStorage (replace with API call in production)
                        const templates = JSON.parse(localStorage.getItem('response_templates')) || [];

                        if (templates.length === 0) {
                            templatesContainer.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">
                            <i class="fas fa-file-alt"></i>
                        </div>
                        <p>No templates yet. Add your first template!</p>
                    </div>
                `;
                            return;
                        }

                        templatesContainer.innerHTML = '';
                        templates.forEach((template, index) => {
                            const templateElement = document.createElement('div');
                            templateElement.className = 'template-item';
                            templateElement.innerHTML = `
                    <div class="template-title">${template.title}</div>
                    <div class="template-content">${template.content.substring(0, 100)}${template.content.length > 100 ? '...' : ''}</div>
                    <div class="template-actions">
                        <button class="template-action-btn template-use-btn" onclick="useTemplate(${index})">
                            <i class="fas fa-paper-plane mr-1"></i> Use
                        </button>
                        <button class="template-action-btn template-edit-btn" onclick="editTemplate(${index})">
                            <i class="fas fa-edit mr-1"></i> Edit
                        </button>
                    </div>
                `;
                            templatesContainer.appendChild(templateElement);
                        });
                    }

                    // Helper function to format file size
                    function formatFileSize(bytes) {
                        if (bytes === 0) return '0 Bytes';
                        const k = 1024;
                        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                        const i = Math.floor(Math.log(bytes) / Math.log(k));
                        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
                    }

                    // ===== VEHICLE & CLAIM EDIT FUNCTIONS =====
                    const ticketId = "{{ ticket.ticket_id }}";

                    // Current vehicle/claim data from template
                    // Current vehicle/claim data from template
                    let currentVehicleData = {
                        vehicle_registration: '',
                        service_date: '',
                        claim_date: '',
                        type_of_claim: '',
                        vhc_link: '',
                        days_between_service_claim: '',
                        advisories_followed: false,
                        within_warranty: false,
                        new_fault_codes: false,
                        dpf_light_on: false,
                        eml_light_on: false
                    };

                    try {
                        const vDataElement = document.getElementById('vehicle-data');
                        if (vDataElement) {
                            const parsedData = JSON.parse(vDataElement.textContent);
                            currentVehicleData = { ...currentVehicleData, ...parsedData };
                        }
                    } catch (e) {
                        console.error('Error parsing vehicle data:', e);
                    }

                    function openVehicleClaimModal() {
                        // Populate form with current data
                        document.getElementById('editVehicleRegistration').value = currentVehicleData.vehicle_registration;
                        document.getElementById('editServiceDate').value = currentVehicleData.service_date;
                        document.getElementById('editClaimDate').value = currentVehicleData.claim_date;
                        document.getElementById('editTypeOfClaim').value = currentVehicleData.type_of_claim;
                        document.getElementById('editVhcLink').value = currentVehicleData.vhc_link;
                        document.getElementById('editDaysBetween').value = currentVehicleData.days_between_service_claim;

                        // Checkboxes
                        document.getElementById('editAdvisoriesFollowed').checked = currentVehicleData.advisories_followed;
                        document.getElementById('editWithinWarranty').checked = currentVehicleData.within_warranty;
                        document.getElementById('editNewFaultCodes').checked = currentVehicleData.new_fault_codes;
                        document.getElementById('editDpfLightOn').checked = currentVehicleData.dpf_light_on;
                        document.getElementById('editEmlLightOn').checked = currentVehicleData.eml_light_on;

                        // Load claim documents
                        loadClaimDocuments();

                        openModal('vehicleClaimModal');
                    }

                    async function saveVehicleClaimInfo() {
                        const data = {
                            vehicle_registration: document.getElementById('editVehicleRegistration').value.trim(),
                            service_date: document.getElementById('editServiceDate').value,
                            claim_date: document.getElementById('editClaimDate').value,
                            type_of_claim: document.getElementById('editTypeOfClaim').value.trim(),
                            vhc_link: document.getElementById('editVhcLink').value.trim(),
                            days_between_service_claim: document.getElementById('editDaysBetween').value,
                            advisories_followed: document.getElementById('editAdvisoriesFollowed').checked,
                            within_warranty: document.getElementById('editWithinWarranty').checked,
                            new_fault_codes: document.getElementById('editNewFaultCodes').checked,
                            dpf_light_on: document.getElementById('editDpfLightOn').checked,
                            eml_light_on: document.getElementById('editEmlLightOn').checked
                        };

                        try {
                            const response = await fetch(`/api/tickets/${ticketId}/vehicle-info`, {
                                method: 'PUT',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(data),
                                credentials: 'include'
                            });

                            const result = await response.json();

                            if (result.success) {
                                showNotification('Vehicle & Claim information updated successfully', 'success');
                                closeModal('vehicleClaimModal');
                                // Refresh the page to show updated data
                                setTimeout(() => location.reload(), 1000);
                            } else {
                                showNotification(result.message || 'Failed to update', 'error');
                            }
                        } catch (error) {
                            console.error('Error saving vehicle info:', error);
                            showNotification('Error saving vehicle information', 'error');
                        }
                    }

                    async function loadClaimDocuments() {
                        const container = document.getElementById('claimDocumentsList');

                        // Helper function to get file icon based on file type
                        function getFileIcon(fileName, fileType) {
                            const ext = fileName.split('.').pop().toLowerCase();
                            if (['jpg', 'jpeg', 'png', 'gif', 'webp'].includes(ext) || fileType?.startsWith('image/')) {
                                return 'fa-file-image text-green-400';
                            } else if (ext === 'pdf' || fileType === 'application/pdf') {
                                return 'fa-file-pdf text-red-400';
                            } else if (['doc', 'docx'].includes(ext) || fileType?.includes('word')) {
                                return 'fa-file-word text-blue-400';
                            } else if (['xls', 'xlsx'].includes(ext) || fileType?.includes('excel') || fileType?.includes('spreadsheet')) {
                                return 'fa-file-excel text-green-500';
                            } else {
                                return 'fa-file text-gray-400';
                            }
                        }

                        // Helper function to check if file is previewable
                        function isPreviewable(fileName, fileType) {
                            const ext = fileName.split('.').pop().toLowerCase();
                            return ['jpg', 'jpeg', 'png', 'gif', 'webp', 'pdf'].includes(ext) ||
                                fileType?.startsWith('image/') ||
                                fileType === 'application/pdf';
                        }

                        // Helper function to format file size
                        function formatSize(bytes) {
                            if (!bytes || bytes === 0) return '';
                            const k = 1024;
                            const sizes = ['B', 'KB', 'MB', 'GB'];
                            const i = Math.floor(Math.log(bytes) / Math.log(k));
                            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
                        }

                        try {
                            const response = await fetch(`/api/tickets/${ticketId}/claim-documents`, { credentials: 'include' });
                            const result = await response.json();
                            const documents = Array.isArray(result.documents) ? result.documents : [];

                            if (result.success && documents.length > 0) {
                                container.innerHTML = documents.map(doc => {
                                    const iconClass = getFileIcon(doc.file_name, doc.file_type);
                                    const canPreview = isPreviewable(doc.file_name, doc.file_type);
                                    const sizeText = formatSize(doc.file_size);

                                    return `
                                <div class="flex items-center justify-between p-2 bg-white/5 rounded-lg mb-2 hover:bg-white/10 transition-colors">
                                    <div class="flex items-center gap-3">
                                        <i class="fas ${iconClass} text-lg"></i>
                                        <div>
                                            <p class="text-sm text-white truncate" style="max-width: 180px;">${doc.file_name}</p>
                                            <p class="text-xs text-gray-500">${doc.description || 'No description'}${sizeText ? ' Â· ' + sizeText : ''}</p>
                                        </div>
                                    </div>
                                    <div class="flex gap-2">
                                        ${canPreview ? `
                                        <a href="/api/tickets/${ticketId}/claim-documents/${doc._id}/download" 
                                           target="_blank"
                                           class="text-purple-400 hover:text-purple-300 text-sm p-1" title="Preview">
                                            <i class="fas fa-eye"></i>
                                        </a>` : ''}
                                        <a href="/api/tickets/${ticketId}/claim-documents/${doc._id}/download" 
                                           class="text-blue-400 hover:text-blue-300 text-sm p-1" title="Download">
                                            <i class="fas fa-download"></i>
                                        </a>
                                        <button onclick="deleteClaimDocument('${doc._id}')" 
                                                class="text-red-400 hover:text-red-300 text-sm p-1" title="Delete">
                                            <i class="fas fa-trash"></i>
                                        </button>
                                    </div>
                                </div>
                            `}).join('');
                            } else {
                                container.innerHTML = '<p class="text-gray-500 text-sm text-center py-2">No claim documents uploaded yet.</p>';
                            }
                        } catch (error) {
                            console.error('Error loading claim documents:', error);
                            container.innerHTML = '<p class="text-red-400 text-sm text-center py-2">Error loading documents</p>';
                        }
                    }

                    async function uploadClaimDocument() {
                        console.log('ðŸ“¤ uploadClaimDocument called');
                        const fileInput = document.getElementById('claimDocumentFile');
                        const description = document.getElementById('claimDocumentDescription').value.trim();

                        console.log('ðŸ“¤ File input:', fileInput);
                        console.log('ðŸ“¤ Files:', fileInput ? fileInput.files : 'null');
                        console.log('ðŸ“¤ Files length:', fileInput ? fileInput.files.length : 'null');

                        if (!fileInput.files.length) {
                            showNotification('Please select a file to upload', 'error');
                            return;
                        }

                        const formData = new FormData();
                        formData.append('file', fileInput.files[0]);
                        formData.append('description', description);

                        console.log('ðŸ“¤ Uploading file:', fileInput.files[0].name, 'Size:', fileInput.files[0].size);
                        console.log('ðŸ“¤ Ticket ID:', ticketId);

                        try {
                            const response = await fetch(`/api/tickets/${ticketId}/claim-documents`, {
                                method: 'POST',
                                body: formData,
                                credentials: 'include'
                            });

                            console.log('ðŸ“¤ Response status:', response.status);
                            const result = await response.json();
                            console.log('ðŸ“¤ Response result:', result);

                            if (result.success) {
                                showNotification('Document uploaded successfully', 'success');
                                fileInput.value = '';
                                document.getElementById('claimDocumentDescription').value = '';

                                // Reset upload zone text
                                const uploadZone = document.querySelector('#vehicleClaimModal .upload-zone');
                                if (uploadZone) {
                                    const textSpan = uploadZone.querySelector('span:first-of-type');
                                    if (textSpan) {
                                        textSpan.textContent = 'Drop files here or click to upload';
                                        textSpan.style.color = '#d1d5db';
                                    }
                                }

                                loadClaimDocuments(); // Refresh modal list
                                loadTicketClaimDocs(); // Refresh main page list
                            } else {
                                showNotification(result.message || 'Failed to upload', 'error');
                            }
                        } catch (error) {
                            console.error('âŒ Error uploading document:', error);
                            showNotification('Error uploading document', 'error');
                        }
                    }

                    async function deleteClaimDocument(docId) {
                        if (!confirm('Are you sure you want to delete this document?')) return;

                        try {
                            const response = await fetch(`/api/tickets/${ticketId}/claim-documents/${docId}`, {
                                method: 'DELETE',
                                credentials: 'include'
                            });

                            const result = await response.json();

                            if (result.success) {
                                showNotification('Document deleted', 'success');
                                loadClaimDocuments(); // Refresh modal list
                                loadTicketClaimDocs(); // Refresh main page list
                            } else {
                                showNotification(result.message || 'Failed to delete', 'error');
                            }
                        } catch (error) {
                            console.error('Error deleting document:', error);
                            showNotification('Error deleting document', 'error');
                        }
                    }

                    // Load claim documents on main ticket page
                    async function loadTicketClaimDocs() {
                        const container = document.getElementById('ticketClaimDocsList');
                        const countSpan = document.getElementById('ticketClaimDocsCount');

                        if (!container) return;

                        // Helper function to get file icon based on file type
                        function getFileIcon(fileName, fileType) {
                            const ext = fileName.split('.').pop().toLowerCase();
                            if (['jpg', 'jpeg', 'png', 'gif', 'webp'].includes(ext) || fileType?.startsWith('image/')) {
                                return 'fa-file-image text-green-500';
                            } else if (ext === 'pdf' || fileType === 'application/pdf') {
                                return 'fa-file-pdf text-red-500';
                            } else if (['doc', 'docx'].includes(ext) || fileType?.includes('word')) {
                                return 'fa-file-word text-blue-500';
                            } else if (['xls', 'xlsx'].includes(ext) || fileType?.includes('excel') || fileType?.includes('spreadsheet')) {
                                return 'fa-file-excel text-green-600';
                            } else {
                                return 'fa-file text-gray-500';
                            }
                        }

                        // Helper function to check if file is previewable
                        function isPreviewable(fileName, fileType) {
                            const ext = fileName.split('.').pop().toLowerCase();
                            return ['jpg', 'jpeg', 'png', 'gif', 'webp', 'pdf'].includes(ext) ||
                                fileType?.startsWith('image/') ||
                                fileType === 'application/pdf';
                        }

                        // Helper function to format file size
                        function formatSize(bytes) {
                            if (!bytes || bytes === 0) return '';
                            const k = 1024;
                            const sizes = ['B', 'KB', 'MB', 'GB'];
                            const i = Math.floor(Math.log(bytes) / Math.log(k));
                            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
                        }

                        try {
                            const response = await fetch(`/api/tickets/${ticketId}/claim-documents`, { credentials: 'include' });
                            const result = await response.json();
                            const documents = Array.isArray(result.documents) ? result.documents : [];

                            if (result.success && documents.length > 0) {
                                if (countSpan) countSpan.textContent = `(${documents.length} file${documents.length > 1 ? 's' : ''})`;

                                container.innerHTML = documents.map(doc => {
                                    const iconClass = getFileIcon(doc.file_name, doc.file_type);
                                    const canPreview = isPreviewable(doc.file_name, doc.file_type);
                                    const sizeText = formatSize(doc.file_size);

                                    return `
                                <div class="detail-card flex items-center justify-between p-3">
                                    <div class="flex items-center gap-3">
                                        <div class="p-2 rounded-full bg-gray-100">
                                            <i class="fas ${iconClass}"></i>
                                        </div>
                                        <div>
                                            <p class="text-sm text-gray-800 font-medium">${doc.file_name}</p>
                                            <p class="text-xs text-gray-500">${doc.description || 'No description'}${sizeText ? ' Â· ' + sizeText : ''}</p>
                                        </div>
                                    </div>
                                    <div class="flex gap-2">
                                        ${canPreview ? `
                                        <a href="/api/tickets/${ticketId}/claim-documents/${doc._id}/download" 
                                           target="_blank"
                                           class="p-2 text-purple-600 hover:bg-purple-100 rounded-full transition" title="Preview">
                                            <i class="fas fa-eye"></i>
                                        </a>` : ''}
                                        <a href="/api/tickets/${ticketId}/claim-documents/${doc._id}/download" 
                                           class="p-2 text-blue-600 hover:bg-blue-100 rounded-full transition" title="Download">
                                            <i class="fas fa-download"></i>
                                        </a>
                                    </div>
                                </div>
                            `}).join('');
                            } else {
                                if (countSpan) countSpan.textContent = '';
                                container.innerHTML = `
                                <div class="detail-card p-4 text-center">
                                    <div class="text-gray-400 mb-2">
                                        <i class="fas fa-folder-open text-2xl"></i>
                                    </div>
                                    <p class="text-gray-500 text-sm">No claim documents uploaded yet.</p>
                                    <p class="text-gray-400 text-xs mt-1">Click "Edit" to upload documents.</p>
                                </div>`;
                            }
                        } catch (error) {
                            console.error('Error loading ticket claim documents:', error);
                            container.innerHTML = '<p class="text-red-400 text-sm text-center py-4">Error loading documents</p>';
                        }
                    }

                    // Make functions globally available for onclick handlers
                    window.deleteClaimDocument = deleteClaimDocument;
                    window.loadTicketClaimDocs = loadTicketClaimDocs;
                    window.uploadClaimDocument = uploadClaimDocument;
                    window.previewAttachment = previewAttachment;
                    window.downloadAttachment = downloadAttachment;
                    window.previewEmailAttachment = previewEmailAttachment;
                    window.downloadEmailAttachment = downloadEmailAttachment;
                    window.previewTicketAttachment = previewTicketAttachment;
                    window.downloadTicketAttachment = downloadTicketAttachment;
                    window.setupAttachmentHandlers = setupAttachmentHandlers;

                    // Event delegation for data-attribute attachment buttons
                    document.addEventListener('click', function (e) {
                        const previewBtn = e.target.closest('.att-preview-btn');
                        if (previewBtn) {
                            const ticketId = previewBtn.dataset.ticketId;
                            const index = parseInt(previewBtn.dataset.index, 10);
                            const filename = previewBtn.dataset.filename;
                            if (window.previewTicketAttachment) {
                                previewTicketAttachment(ticketId, index, filename);
                            }
                            return;
                        }
                        const downloadBtn = e.target.closest('.att-download-btn');
                        if (downloadBtn) {
                            const ticketId = downloadBtn.dataset.ticketId;
                            const index = parseInt(downloadBtn.dataset.index, 10);
                            const filename = downloadBtn.dataset.filename;
                            if (window.downloadTicketAttachment) {
                                downloadTicketAttachment(ticketId, index, filename);
                            }
                            return;
                        }
                    });

                    // ==========================================
                    // ATTACHMENT HANDLING FUNCTIONS
                    // ==========================================

                    // â”€â”€â”€ Inline Preview Modal (avoids popup blockers) â”€â”€â”€
                    function getOrCreatePreviewModal() {
                        let modal = document.getElementById('attachmentPreviewModal');
                        if (!modal) {
                            modal = document.createElement('div');
                            modal.id = 'attachmentPreviewModal';
                            modal.style.cssText = `
                            display:none; position:fixed; inset:0; z-index:99999;
                            background:rgba(0,0,0,0.85); backdrop-filter:blur(8px);
                            align-items:center; justify-content:center; flex-direction:column;
                        `;
                            modal.innerHTML = `
                            <div style="position:absolute;top:16px;right:24px;display:flex;gap:12px;z-index:100001;">
                                <a id="prevModalOpenTab" href="#" target="_blank" rel="noopener"
                                   style="color:#a78bfa;font-size:14px;text-decoration:underline;padding:8px;">
                                    Open in new tab
                                </a>
                                <button id="prevModalClose"
                                    style="color:#fff;font-size:28px;background:rgba(255,255,255,0.1);
                                           border:none;border-radius:50%;width:40px;height:40px;
                                           cursor:pointer;display:flex;align-items:center;justify-content:center;">
                                    âœ•
                                </button>
                            </div>
                            <div id="prevModalContent" style="max-width:90vw;max-height:85vh;display:flex;
                                 align-items:center;justify-content:center;"></div>
                        `;
                            document.body.appendChild(modal);

                            // Close handlers
                            modal.querySelector('#prevModalClose').addEventListener('click', () => {
                                modal.style.display = 'none';
                                modal.querySelector('#prevModalContent').innerHTML = '';
                            });
                            modal.addEventListener('click', (e) => {
                                if (e.target === modal) {
                                    modal.style.display = 'none';
                                    modal.querySelector('#prevModalContent').innerHTML = '';
                                }
                            });
                            document.addEventListener('keydown', (e) => {
                                if (e.key === 'Escape' && modal.style.display === 'flex') {
                                    modal.style.display = 'none';
                                    modal.querySelector('#prevModalContent').innerHTML = '';
                                }
                            });
                        }
                        return modal;
                    }

                    function showPreviewInModal(url, filename) {
                        const modal = getOrCreatePreviewModal();
                        const content = modal.querySelector('#prevModalContent');
                        const openTab = modal.querySelector('#prevModalOpenTab');
                        openTab.href = url;
                        content.innerHTML = '';

                        const ext = (filename || '').toLowerCase().split('.').pop();
                        const imageExts = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'svg'];

                        if (imageExts.includes(ext)) {
                            const img = document.createElement('img');
                            img.src = url;
                            img.alt = filename;
                            img.style.cssText = 'max-width:90vw;max-height:85vh;object-fit:contain;border-radius:8px;box-shadow:0 8px 32px rgba(0,0,0,0.4);';
                            content.appendChild(img);
                        } else {
                            // PDF / text / other â€” use iframe
                            const iframe = document.createElement('iframe');
                            iframe.src = url;
                            iframe.style.cssText = 'width:85vw;height:85vh;border:none;border-radius:8px;background:#fff;';
                            content.appendChild(iframe);
                        }

                        modal.style.display = 'flex';
                    }

                    function previewAttachment(messageId, attachmentIndex, filename, source) {
                        console.log('previewAttachment called:', { messageId, attachmentIndex, filename, source });
                        const url = `/api/attachments/reply/${messageId}/${attachmentIndex}/preview`;
                        showPreviewInModal(url, filename);
                    }

                    function downloadAttachment(messageId, attachmentIndex, filename, source) {
                        console.log('downloadAttachment called:', { messageId, attachmentIndex, filename, source });
                        const url = `/api/attachments/reply/${messageId}/${attachmentIndex}`;
                        console.log('Downloading from URL:', url);
                        window.location.href = url;
                    }

                    function previewEmailAttachment(ticketId, attachmentIndex, filename) {
                        console.log('previewEmailAttachment called:', { ticketId, attachmentIndex, filename });
                        const url = `/api/attachments/preview/${ticketId}/${attachmentIndex}`;
                        showPreviewInModal(url, filename);
                    }

                    function downloadEmailAttachment(ticketId, attachmentIndex, filename) {
                        console.log('downloadEmailAttachment called:', { ticketId, attachmentIndex, filename });
                        const url = `/api/attachments/ticket/${ticketId}/${attachmentIndex}`;
                        console.log('Downloading from URL:', url);
                        window.location.href = url;
                    }

                    // Original Ticket Attachment Functions
                    function previewTicketAttachment(ticketId, attachmentIndex, filename) {
                        console.log('previewTicketAttachment called:', { ticketId, attachmentIndex, filename });
                        const url = `/api/attachments/preview/${ticketId}/${attachmentIndex}`;
                        showPreviewInModal(url, filename);
                    }

                    function downloadTicketAttachment(ticketId, attachmentIndex, filename) {
                        console.log('downloadTicketAttachment called:', { ticketId, attachmentIndex, filename });
                        const url = `/api/attachments/ticket/${ticketId}/${attachmentIndex}`;
                        console.log('Downloading from URL:', url);
                        window.location.href = url;
                    }

                    function setupAttachmentHandlers() {
                        // This function is called in DOMContentLoaded
                        console.log('Attachment handlers initialized');

                        const dropzone = document.getElementById('replyDropzone');
                        const fileInput = document.getElementById('response_attachments');

                        if (dropzone && fileInput) {
                            dropzone.addEventListener('click', (e) => {
                                // Only trigger if clicking the background, not textarea or buttons
                                if (e.target.id === 'replyDropzone' || e.target.closest('#attachmentSection')) {
                                    fileInput.click();
                                }
                            });

                            fileInput.addEventListener('change', handleFileSelect);
                        }

                        // Also enable the generic attachment button
                        const attachmentBtn = document.getElementById('attachmentBtn');
                        if (attachmentBtn && fileInput) {
                            attachmentBtn.addEventListener('click', () => fileInput.click());
                        }
                    }

                    function handleFileSelect(e) {
                        const files = e.target.files;
                        const previewContainer = document.getElementById('enhancedAttachmentPreview');
                        const list = document.getElementById('attachmentPreviewList');

                        if (files.length > 0) {
                            previewContainer.classList.remove('hidden');
                            list.innerHTML = '';

                            Array.from(files).forEach((file, index) => {
                                const item = document.createElement('div');
                                item.className = 'flex items-center justify-between text-xs bg-white/5 p-2 rounded';
                                item.innerHTML = `
                                <div class="flex items-center">
                                    <i class="fas fa-file text-gray-400 mr-2"></i>
                                    <span class="text-gray-300 truncate max-w-[200px]">${file.name}</span>
                                </div>
                                <span class="text-gray-500 ml-2">${(file.size / 1024).toFixed(1)} KB</span>
                            `;
                                list.appendChild(item);
                            });

                            // Update button counter
                            const countBadge = document.querySelector('.attachment-count');
                            if (countBadge) {
                                countBadge.textContent = files.length;
                                countBadge.classList.remove('hidden');
                            }
                        }
                    }

                    // Document functions
                    let isLoadingDocuments = false; // Prevent duplicate loading
                    const loadedDocumentIds = new Set(); // Track loaded document IDs

                    async function loadDocuments() {
                        // Prevent concurrent calls
                        if (isLoadingDocuments) {
                            console.log('âš ï¸ loadDocuments already in progress, skipping...');
                            return;
                        }

                        isLoadingDocuments = true;

                        const documentsSection = document.getElementById('documentsContainer');

                        if (!documentsSection) {
                            console.error('Documents container not found');
                            isLoadingDocuments = false;
                            return;
                        }

                        try {
                            const response = await fetch('/api/common-documents', { credentials: 'include' });
                            const data = await response.json();

                            if (!response.ok) {
                                throw new Error(data.message || 'Failed to load documents');
                            }

                            const documents = data.documents || [];

                            // DEBUG: Log the document structure to see what fields are available
                            console.log('ðŸ“„ Loaded documents:', documents);
                            if (documents.length > 0) {
                                console.log('ðŸ“„ First document structure:', documents[0]);
                                console.log('ðŸ“„ Document has file_content:', 'file_content' in documents[0]);
                                console.log('ðŸ“„ Document has file_data:', 'file_data' in documents[0]);
                                console.log('ðŸ“„ Document has file_size:', 'file_size' in documents[0]);
                            }

                            // Store documents in localStorage for drag and drop functionality
                            localStorage.setItem('common_documents', JSON.stringify(documents));

                            // Clear the container first
                            documentsSection.innerHTML = '';

                            if (documents.length === 0) {
                                // Show empty state message
                                documentsSection.innerHTML = `
                    <div class="text-center text-gray-500 p-4">
                        <i class="fas fa-folder-open text-3xl mb-2"></i>
                        <p class="text-sm">No documents yet. Click "Add Document" to get started.</p>
                    </div>
                `;
                                return;
                            }

                            // Create document items
                            documents.forEach((doc, arrayIndex) => {


                                if (!doc._id) {
                                    console.error('Document missing _id field:', doc);
                                    return; // Skip this document
                                }

                                const docItem = document.createElement('div');
                                // Force vertical layout with inline style to override any CSS conflicts
                                docItem.className = 'document-item border-b border-gray-700/50 p-3 bg-gray-800/30 hover:bg-gray-800/50 cursor-pointer flex flex-col gap-2';
                                docItem.style.cssText = 'display: flex !important; flex-direction: column !important; gap: 0.5rem !important; background: rgba(255, 255, 255, 0.03) !important;';
                                docItem.dataset.documentId = doc._id;

                                // Choose appropriate icon based on file extension (primary) or document type (fallback)
                                let iconClass = 'fas fa-file-alt text-gray-400';

                                // Get file extension from file_name if available
                                const fileName = doc.file_name || doc.name || '';
                                const ext = fileName.toLowerCase().split('.').pop();

                                // Extension-based icon mapping (priority)
                                if (ext === 'pdf') {
                                    iconClass = 'fas fa-file-pdf text-red-500';
                                } else if (ext === 'doc' || ext === 'docx') {
                                    iconClass = 'fas fa-file-word text-blue-500';
                                } else if (ext === 'xls' || ext === 'xlsx') {
                                    iconClass = 'fas fa-file-excel text-green-500';
                                } else if (ext === 'csv') {
                                    iconClass = 'fas fa-file-csv text-green-500';
                                } else if (['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp'].includes(ext)) {
                                    iconClass = 'fas fa-file-image text-purple-500';
                                } else if (ext === 'zip' || ext === 'rar' || ext === '7z') {
                                    iconClass = 'fas fa-file-archive text-yellow-500';
                                } else if (ext === 'txt') {
                                    iconClass = 'fas fa-file-alt text-gray-400';
                                } else if (doc.type === 'form') {
                                    // Fallback to document type
                                    iconClass = 'fas fa-file-contract text-blue-500';
                                } else if (doc.type === 'guide') {
                                    iconClass = 'fas fa-book text-green-500';
                                } else if (doc.type === 'manual') {
                                    iconClass = 'fas fa-file-pdf text-red-500';
                                } else if (doc.type === 'template') {
                                    iconClass = 'fas fa-file-word text-indigo-500';
                                }

                                // Format date and file size
                                const createdDate = new Date(doc.created_at).toLocaleDateString();
                                const fileSize = doc.file_size ? formatFileSize(doc.file_size) : '';

                                // Use high-contrast colors for dark mode text
                                docItem.innerHTML = `
                    <div class="flex items-start w-full" style="display: flex !important; width: 100% !important;">
                        <i class="${iconClass} text-xl mr-3 mt-0.5 flex-shrink-0"></i>
                        <div class="flex-1 min-w-0 grid">
                            <p class="text-sm font-medium text-gray-100 truncate" title="${doc.name}">${doc.name}</p>
                            <p class="text-xs text-gray-400 truncate mt-0.5">${doc.type ? doc.type.charAt(0).toUpperCase() + doc.type.slice(1) : 'Doc'} â€¢ ${createdDate}</p>
                        </div>
                    </div>
                    
                    <!-- Tiny Action Buttons Row - Forced Visibility -->
                    <div class="common-doc-actions flex items-center gap-2 pl-8 mt-1 w-full" style="display: flex !important; margin-top: 4px !important; padding-left: 2rem !important; width: 100% !important; visibility: visible !important; opacity: 1 !important;">
                        <button type="button" class="view-document-btn text-xs bg-gray-800 text-blue-400 hover:bg-gray-700 hover:text-blue-300 px-2 py-1 rounded border border-gray-600 transition-colors flex items-center gap-1 h-6" style="display: inline-flex !important;" title="Download">
                            <i class="fas fa-download text-[10px]"></i> <span class="text-[10px] font-medium">Download</span>
                        </button>
                        
                        <div class="flex gap-1 ml-auto" style="display: flex !important; margin-left: auto !important;">
                             <button type="button" class="delete-document-btn text-xs bg-gray-800 text-red-400 hover:bg-gray-700 hover:text-red-300 px-2 py-1 rounded border border-gray-600 transition-colors flex items-center gap-1 h-6" style="display: inline-flex !important;" title="Delete">
                                <i class="fas fa-trash text-[10px]"></i> <span class="text-[10px] font-medium">Delete</span>
                            </button>
                            <button type="button" class="edit-document-btn text-xs bg-gray-800 text-gray-400 hover:bg-gray-700 hover:text-gray-300 px-2 py-1 rounded border border-gray-600 transition-colors flex items-center gap-1 h-6" style="display: inline-flex !important;" title="Edit">
                                <i class="fas fa-edit text-[10px]"></i> <span class="text-[10px] font-medium">Edit</span>
                            </button>
                        </div>
                    </div>
                `;

                                documentsSection.appendChild(docItem);

                                // Make document draggable
                                docItem.setAttribute('draggable', 'true');
                                docItem.addEventListener('dragstart', function (e) {
                                    // Get the index of this document in the current list
                                    const allDocItems = documentsSection.querySelectorAll('.document-item');
                                    const currentIndex = Array.from(allDocItems).indexOf(docItem);

                                    console.log(`ðŸš€ Drag started for document ${doc._id} at index ${currentIndex} (array index: ${arrayIndex})`);
                                    console.log('ðŸ“‹ Drag data being set:', {
                                        type: 'common-document',
                                        _id: doc._id,
                                        name: doc.name,
                                        documentId: doc._id
                                    });

                                    // ENHANCED DEBUGGING: Log complete document details
                                    console.log('ðŸ” COMPLETE DOCUMENT DATA FOR DRAG:', {
                                        _id: doc._id,
                                        name: doc.name,
                                        type: doc.type,
                                        description: doc.description,
                                        file_name: doc.file_name,
                                        file_size: doc.file_size,
                                        file_path: doc.file_path,
                                        created_at: doc.created_at,
                                        updated_at: doc.updated_at,
                                        is_active: doc.is_active,
                                        arrayIndex: arrayIndex,
                                        currentIndex: currentIndex,
                                        documentElement: docItem,
                                        elementDataset: docItem.dataset,
                                        doc_type: doc.datatype,
                                        file_data: "",
                                        file_name: ""
                                    });

                                    // Store the drag data for debugging
                                    const dragData = {
                                        type: 'common-document',
                                        _id: doc._id,  // Use actual document ID instead of index
                                        name: doc.name,
                                        documentId: doc._id,
                                        // ENHANCED: Include more document details for debugging
                                        documentType: doc.type,
                                        documentDescription: doc.description,
                                        documentFileName: doc.file_name,
                                        documentFileSize: doc.file_size,
                                        documentFilePath: doc.file_path,
                                        documentCreatedAt: doc.created_at,
                                        documentUpdatedAt: doc.updated_at,
                                        documentIsActive: doc.is_active
                                    };

                                    e.dataTransfer.setData('text', JSON.stringify(dragData));

                                    // Add visual feedback
                                    e.target.classList.add('opacity-50');

                                    // Log the current state of processed documents
                                    console.log('ðŸ“Š Current processed documents:', Array.from(processedDocuments));
                                    console.log('ðŸ“Š Current processed documents count:', processedDocuments.size);
                                });

                                docItem.addEventListener('dragend', function (e) {
                                    e.target.classList.remove('opacity-50');
                                });

                                // Add view button event handler
                                const viewBtn = docItem.querySelector('.view-document-btn');
                                if (viewBtn) {
                                    viewBtn.addEventListener('click', function (e) {
                                        e.stopPropagation();
                                        console.log('View button clicked, doc._id:', doc._id);
                                        console.log('View button clicked, doc._id type:', typeof doc._id);
                                        console.log('View button clicked, doc._id length:', doc._id ? doc._id.length : 'null/undefined');
                                        viewDocument(doc._id);
                                    });
                                }

                                // Add edit button event handler
                                const editBtn = docItem.querySelector('.edit-document-btn');
                                if (editBtn) {
                                    editBtn.addEventListener('click', function (e) {
                                        e.stopPropagation();
                                        editDocument(doc._id);
                                    });
                                }



                                // Add delete button event handler
                                const deleteBtn = docItem.querySelector('.delete-document-btn');
                                if (deleteBtn) {
                                    deleteBtn.addEventListener('click', function (e) {
                                        e.stopPropagation();
                                        deleteDocument(doc._id);
                                    });
                                }

                                // Add click handler for the entire item (for viewing)
                                docItem.addEventListener('click', function () {
                                    console.log('Document item clicked, doc._id:', doc._id);
                                    console.log('Document item clicked, doc._id type:', typeof doc._id);
                                    console.log('Document item clicked, doc._id length:', doc._id ? doc._id.length : 'null/undefined');
                                    viewDocument(doc._id);
                                });
                            });

                            console.log('Documents loaded and made draggable');

                            // Reset processed documents tracking when documents are reloaded
                            processedDocuments.clear();
                            lastProcessedDocument = null;
                            lastProcessedTime = 0;

                            // Setup drag and drop for reply area
                            // setupReplyDropzone(); // OLD SYSTEM REMOVED

                            isLoadingDocuments = false; // Reset loading flag

                        } catch (error) {
                            console.error('Error loading documents:', error);
                            isLoadingDocuments = false; // Reset loading flag on error
                            documentsSection.innerHTML = `
                    <div class="text-center text-red-500 p-4">
                        <i class="fas fa-exclamation-triangle text-3xl mb-2"></i>
                        <p class="text-sm">Error loading documents: ${error.message}</p>
                    </div>
                `;
                        }
                    }

                    // OLD DRAG & DROP SYSTEM REMOVED - Only enhanced system remains
                    /*
                    function setupReplyDropzone() {
                        // ... entire old function commented out ...
                    }
                    */

                    // OLD FUNCTION REMOVED - Only enhanced system remains
                    /*
                    // Add common document to reply as attachment
                    function addCommonDocumentToReply(documentId, documentName, fullDocumentData = null) {
                        console.log('ðŸ“„ addCommonDocumentToReply called with:');
                        console.log('  - documentId:', documentId);
                        console.log('  - documentName:', documentName);
                        console.log('  - fullDocumentData:', fullDocumentData);
                        
                        // Check for duplicate documents before adding
                        const commonDocumentPreview = document.getElementById('commonDocumentPreview');
                        if (commonDocumentPreview) {
                            const existingDoc = commonDocumentPreview.querySelector(`[data-document-id="${documentId}"]`);
                            if (existingDoc) {
                                console.log('âš ï¸ Document already added to reply, skipping duplicate:', documentName);
                                showNotification(`ðŸ“„ ${documentName} is already added to reply`, 'warning');
                                return;
                            }
                        }
                        
                        // ENHANCED DEBUGGING: Log all available document information
                        if (fullDocumentData) {
                            console.log('ðŸ” COMPLETE DOCUMENT DATA RECEIVED:');
                            console.log('  - Document ID:', fullDocumentData.documentId);
                            console.log('  - Document Name:', fullDocumentData.name);
                            console.log('  - Document Type:', fullDocumentData.documentType);
                            console.log('  - Document Description:', fullDocumentData.documentDescription);
                            console.log('  - Document File Name:', fullDocumentData.documentFileName);
                            console.log('  - Document File Size:', fullDocumentData.documentFileSize);
                            console.log('  - Document File Path:', fullDocumentData.documentFilePath);
                            console.log('  - Document Created At:', fullDocumentData.documentCreatedAt);
                            console.log('  - Document Updated At:', fullDocumentData.documentUpdatedAt);
                            console.log('  - Document Is Active:', fullDocumentData.documentIsActive);
                            console.log('  - Array Index:', fullDocumentData.index);
                        }
                        
                        // ENHANCED DEBUGGING: Check localStorage for additional context
                        try {
                            const storedDocuments = JSON.parse(localStorage.getItem('common_documents') || '[]');
                            console.log('ðŸ’¾ Stored documents in localStorage:', storedDocuments.length);
                            
                            const matchingStoredDoc = storedDocuments.find(doc => doc._id === documentId);
                            if (matchingStoredDoc) {
                                console.log('ðŸŽ¯ Found matching document in localStorage:', matchingStoredDoc);
                            } else {
                                console.log('âš ï¸ Document not found in localStorage - ID mismatch?');
                                console.log('ðŸ” Searching for partial matches...');
                                const partialMatches = storedDocuments.filter(doc => 
                                    doc._id && doc._id.toString().includes(documentId.toString().slice(-4))
                                );
                                console.log('ðŸ” Partial matches found:', partialMatches);
                            }
                        } catch (localStorageError) {
                            console.error('ðŸ’¥ Error reading localStorage:', localStorageError);
                        }
                        
                        const commonDocumentDropzone = document.getElementById('commonDocumentDropzone');
                        
                        console.log('ðŸŽ¯ DOM Elements found:');
                        console.log('  - commonDocumentDropzone:', commonDocumentDropzone);
                        console.log('  - commonDocumentPreview:', commonDocumentPreview);
                        
                        // Show the dropzone if hidden
                        commonDocumentDropzone.classList.remove('hidden');
                        
                        // Create preview item
                        const previewItem = document.createElement('div');
                        previewItem.className = 'flex items-center justify-between p-2 bg-blue-50 border border-blue-200 rounded text-sm';
                        previewItem.dataset.documentId = documentId;
                        
                        // ENHANCED: Store all document data in the preview item for debugging
                        if (fullDocumentData) {
                            previewItem.dataset.documentType = fullDocumentData.documentType || '';
                            previewItem.dataset.documentDescription = fullDocumentData.documentDescription || '';
                            previewItem.dataset.documentFileName = fullDocumentData.documentFileName || '';
                            previewItem.dataset.documentFileSize = fullDocumentData.documentFileSize || '';
                            previewItem.dataset.documentFilePath = fullDocumentData.documentFilePath || '';
                            previewItem.dataset.documentCreatedAt = fullDocumentData.documentCreatedAt || '';
                            previewItem.dataset.documentUpdatedAt = fullDocumentData.documentUpdatedAt || '';
                            previewItem.dataset.documentIsActive = fullDocumentData.documentIsActive || '';
                            previewItem.dataset.arrayIndex = fullDocumentData.index || '';
                        }
                        
                        console.log('ðŸŽ¨ Preview item created with dataset:', previewItem.dataset);
                        
                        previewItem.innerHTML = `
                            <div class="flex items-center">
                                <i class="fas fa-file-alt text-blue-500 mr-2"></i>
                                <span class="text-blue-800">${documentName}</span>
                                ${fullDocumentData && fullDocumentData.documentType ? `<span class="text-xs text-blue-600 ml-2">(${fullDocumentData.documentType})</span>` : ''}
                            </div>
                            <button type="button" class="remove-doc-btn text-red-500 hover:text-red-700" title="Remove">
                                <i class="fas fa-times"></i>
                            </button>
                        `;
                        
                        // Add remove functionality
                        const removeBtn = previewItem.querySelector('.remove-doc-btn');
                        removeBtn.addEventListener('click', function() {
                            previewItem.remove();
                            // Hide dropzone if no more documents
                            if (commonDocumentPreview.children.length === 0) {
                                commonDocumentDropzone.classList.add('hidden');
                            }
                        });
                        
                        commonDocumentPreview.appendChild(previewItem);
                        
                        // Show success notification
                        showNotification(`ðŸ“„ ${documentName} added to reply`, 'success');
                    }
                    */

                    async function viewDocument(documentId) {
                        try {
                            if (!documentId) {
                                showNotification('No document ID provided', 'error');
                                return;
                            }

                            // Download the document file
                            const downloadUrl = `/api/common-documents/${documentId}/download`;

                            try {
                                const newWindow = window.open(downloadUrl, '_blank');
                                if (!newWindow) {
                                    showNotification('Download failed - popup blocked?', 'error');
                                }
                            } catch (windowError) {
                                showNotification(`Error opening download: ${windowError.message}`, 'error');
                            }

                        } catch (error) {
                            console.error('Error viewing document:', error);
                            showNotification(`Error viewing document: ${error.message}`, 'error');
                        }
                    }

                    async function editDocument(documentId) {
                        try {
                            const response = await fetch(`/api/common-documents/${documentId}`);
                            const data = await response.json();

                            if (!response.ok) {
                                throw new Error(data.message || 'Document not found');
                            }

                            const doc = data.document;

                            document.getElementById('documentName').value = doc.name;
                            document.getElementById('documentType').value = doc.type;
                            document.getElementById('documentDescription').value = doc.description || '';
                            document.getElementById('selectedFileName').textContent = doc.file_name || 'Current file preserved';
                            document.getElementById('documentModalTitle').textContent = 'Edit Document';
                            document.getElementById('deleteDocument').classList.remove('hidden');
                            document.getElementById('saveDocument').setAttribute('data-document-id', documentId);
                            openModal('documentModal');

                        } catch (error) {
                            console.error('Error loading document for editing:', error);
                            showNotification(`Error loading document: ${error.message}`, 'error');
                        }
                    }

                    async function saveDocument() {
                        const name = document.getElementById('documentName').value.trim();
                        const type = document.getElementById('documentType').value;
                        const fileInput = document.getElementById('documentFile');
                        const description = document.getElementById('documentDescription').value.trim();
                        const documentId = document.getElementById('saveDocument').getAttribute('data-document-id');

                        if (!name) {
                            showNotification('Please enter a document name', 'error');
                            return;
                        }

                        // For new documents, require a file
                        if (!documentId && fileInput.files.length === 0) {
                            showNotification('Please select a file for new documents', 'error');
                            return;
                        }

                        try {
                            let response;

                            if (documentId) {
                                // Update existing document (JSON)
                                const documentData = {
                                    name,
                                    type,
                                    description,
                                    file_name: fileInput.files.length > 0 ? fileInput.files[0].name : ''
                                };

                                response = await fetch(`/api/common-documents/${documentId}`, {
                                    method: 'PUT',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify(documentData),
                                    credentials: 'include'
                                });
                            } else {
                                // Create new document with file upload (FormData)
                                const formData = new FormData();
                                formData.append('name', name);
                                formData.append('type', type);
                                formData.append('description', description);
                                formData.append('file', fileInput.files[0]);

                                response = await fetch('/api/common-documents', {
                                    method: 'POST',
                                    body: formData,
                                    credentials: 'include'
                                });
                            }

                            const data = await response.json();

                            if (!response.ok) {
                                throw new Error(data.message || 'Failed to save document');
                            }

                            // Refresh documents display
                            await loadDocuments();

                            // Close modal and show notification
                            closeModal('documentModal');
                            showNotification(documentId ? 'Document updated successfully' : 'Document uploaded successfully');

                            // Clear form
                            document.getElementById('documentName').value = '';
                            document.getElementById('documentType').value = 'form';
                            document.getElementById('documentDescription').value = '';
                            document.getElementById('documentFile').value = '';
                            document.getElementById('selectedFileName').textContent = 'No file selected';

                        } catch (error) {
                            console.error('Error saving document:', error);
                            showNotification(`Error saving document: ${error.message}`, 'error');
                        }
                    }

                    async function deleteDocument(documentId) {
                        if (!documentId || !confirm('Are you sure you want to delete this document?')) {
                            return;
                        }

                        try {
                            const response = await fetch(`/api/common-documents/${documentId}`, {
                                method: 'DELETE',
                                credentials: 'include'
                            });

                            const data = await response.json();

                            if (!response.ok) {
                                throw new Error(data.message || 'Failed to delete document');
                            }

                            // Refresh documents display
                            await loadDocuments();

                            // Close modal if open
                            closeModal('documentModal');
                            showNotification('Document deleted successfully');

                        } catch (error) {
                            console.error('Error deleting document:', error);
                            showNotification(`Error deleting document: ${error.message}`, 'error');
                        }
                    }

                    function useTemplate(index) {
                        const templates = JSON.parse(localStorage.getItem('response_templates')) || [];

                        if (index >= 0 && index < templates.length) {
                            const responseTextarea = document.getElementById('response');
                            responseTextarea.value = templates[index].content;

                            // Trigger auto-expand after applying template
                            if (typeof window.autoExpandTextarea === 'function') {
                                window.autoExpandTextarea(responseTextarea);
                            }

                            showNotification('Template applied to response');
                        }
                    }

                    function editTemplate(index = -1) {
                        const templates = JSON.parse(localStorage.getItem('response_templates')) || [];

                        if (index >= 0 && index < templates.length) {
                            // Editing existing template
                            const template = templates[index];
                            document.getElementById('templateTitle').value = template.title;
                            document.getElementById('templateContent').value = template.content;
                            document.getElementById('editTemplateTitle').textContent = 'Edit Template';
                            document.getElementById('deleteTemplate').classList.remove('hidden');
                            document.getElementById('saveTemplate').setAttribute('data-template-index', index);
                        } else {
                            // Creating new template
                            document.getElementById('templateTitle').value = '';
                            document.getElementById('templateContent').value = '';
                            document.getElementById('editTemplateTitle').textContent = 'Add New Template';
                            document.getElementById('deleteTemplate').classList.add('hidden');
                            document.getElementById('saveTemplate').removeAttribute('data-template-index');
                        }

                        openModal('editTemplateModal');
                    }

                    function saveTemplate() {
                        const title = document.getElementById('templateTitle').value.trim();
                        const content = document.getElementById('templateContent').value.trim();
                        const index = document.getElementById('saveTemplate').getAttribute('data-template-index');

                        if (!title || !content) {
                            showNotification('Please fill in both title and content', 'error');
                            return;
                        }

                        const templates = JSON.parse(localStorage.getItem('response_templates')) || [];

                        if (index !== null) {
                            // Update existing template
                            templates[index] = { title, content };
                        } else {
                            // Add new template
                            templates.push({ title, content });
                        }

                        localStorage.setItem('response_templates', JSON.stringify(templates));
                        loadTemplates();
                        closeModal('editTemplateModal');
                        showNotification(index !== null ? 'Template updated successfully' : 'Template saved successfully');
                    }

                    function deleteTemplate() {
                        const index = document.getElementById('saveTemplate').getAttribute('data-template-index');

                        if (index !== null && confirm('Are you sure you want to delete this template?')) {
                            const templates = JSON.parse(localStorage.getItem('response_templates')) || [];

                            if (index >= 0 && index < templates.length) {
                                templates.splice(index, 1);
                                localStorage.setItem('response_templates', JSON.stringify(templates));
                                loadTemplates();
                                closeModal('editTemplateModal');
                                showNotification('Template deleted');
                            }
                        }
                    }

                    // Status dropdown functionality
                    function setupStatusDropdown() {
                        const dropdownBtn = document.getElementById('statusDropdownBtn');
                        const dropdownContent = document.getElementById('statusDropdownContent');

                        // Toggle dropdown
                        dropdownBtn.addEventListener('click', function (e) {
                            e.stopPropagation();
                            dropdownContent.classList.toggle('show');
                        });

                        // Close dropdown when clicking outside
                        document.addEventListener('click', function () {
                            dropdownContent.classList.remove('show');
                        });

                        // Handle status selection
                        document.querySelectorAll('.status-option').forEach(option => {
                            option.addEventListener('click', async function () {
                                const newStatus = this.getAttribute('data-status');

                                try {
                                    const response = await fetch(`/api/tickets/{{ ticket.ticket_id }}/status`, {
                                        method: 'PUT',
                                        headers: {
                                            'Content-Type': 'application/json',
                                        },
                                        body: JSON.stringify({
                                            status: newStatus
                                        })
                                    });

                                    if (response.ok) {
                                        // Get the CURRENT status from the DOM (not the static template value)
                                        const statusDisplay = document.getElementById('currentStatusDisplay');
                                        const oldStatus = statusDisplay ? statusDisplay.textContent.trim() : '';
                                        const newStatusClass = newStatus.toLowerCase().replace(/ /g, '-').replace(/â€“/g, '');

                                        // Update the status dropdown button text
                                        if (statusDisplay) {
                                            statusDisplay.textContent = newStatus;
                                        }

                                        // Update the status dropdown button styling
                                        const statusDropdownBtn = document.getElementById('statusDropdownBtn');
                                        if (statusDropdownBtn) {
                                            // Remove ALL old status classes and add new one
                                            statusDropdownBtn.className = 'status-dropdown-btn whitespace-nowrap flex-shrink-0 h-9 flex items-center justify-center';
                                            statusDropdownBtn.classList.add(`status-${newStatusClass}`);
                                        }

                                        // Update ALL status badges on the page
                                        const statusBadges = document.querySelectorAll('[class*="status-"]');
                                        statusBadges.forEach(badge => {
                                            if (badge.textContent.trim() === oldStatus) {
                                                badge.textContent = newStatus;
                                                // Update badge classes
                                                badge.className = badge.className.replace(/status-\S+/g, '');
                                                badge.classList.add(`status-${newStatusClass}`);
                                            }
                                        });

                                        showNotification(`Status updated to ${newStatus}`, 'success');
                                    } else {
                                        const error = await response.json();
                                        showNotification(error.message || 'Failed to update status', 'error');
                                    }
                                } catch (error) {
                                    console.error('Error updating status:', error);
                                    showNotification('Failed to update status', 'error');
                                }
                            });
                        });
                    }

                    // Function to initialize status dropdown button styling
                    function initializeStatusButton() {
                        const statusDropdownBtn = document.getElementById('statusDropdownBtn');
                        const currentStatus = '{{ ticket.status }}';

                        if (statusDropdownBtn && currentStatus) {
                            // Remove any existing status classes
                            statusDropdownBtn.className = statusDropdownBtn.className.replace(/status-\S+/g, '');

                            // Add the current status class
                            const statusClass = currentStatus.toLowerCase().replace(/ /g, '-').replace(/â€“/g, '');
                            statusDropdownBtn.classList.add(`status-${statusClass}`);
                        }
                    }

                    // Function to force 1500px layout for ALL screen sizes
                    function adjustLayoutForScreenSize() {
                        const appContainer = document.querySelector('.app-container');

                        if (appContainer) {
                            // ALWAYS force 1500px width regardless of screen size
                            appContainer.style.width = '1500px';
                            appContainer.style.maxWidth = '1500px';
                            appContainer.style.margin = '0'; /* Ensure left alignment */

                            // ALWAYS apply professional styling
                            appContainer.style.boxShadow = '0 0 30px rgba(0, 0, 0, 0.1)';
                            appContainer.style.borderRadius = '8px';
                            appContainer.style.marginTop = '20px';
                            appContainer.style.marginBottom = '20px';

                            // Color setting removed to maintain dark theme consistency
                            // document.body.style.backgroundColor = '#f8fafb';

                            // ALWAYS align to left instead of center
                            document.body.style.display = 'flex';
                            document.body.style.justifyContent = 'flex-start'; /* Changed from center to flex-start */
                            document.body.style.alignItems = 'flex-start';
                            document.body.style.minHeight = '100vh';

                            console.log('âœ… Forced 1500px layout applied for all screen sizes with LEFT alignment');
                        }
                    }

                    // Run layout adjustment on window resize
                    window.addEventListener('resize', adjustLayoutForScreenSize);

                    // Also run on initial page load
                    window.addEventListener('load', adjustLayoutForScreenSize);

                    // CRITICAL FIX: Ensure sidebar is hidden after all resources load
                    window.addEventListener('load', function () {
                        setTimeout(() => {
                            const rightSidebar = document.querySelector('.right-sidebar');
                            const appContainer = document.querySelector('.app-container');

                            if (rightSidebar) {
                                // Force hide sidebar after page load
                                rightSidebar.classList.remove('sidebar-open', 'ultra-wide-open', 'mobile-open');
                                rightSidebar.style.transform = 'translateX(200%)';
                                rightSidebar.style.visibility = 'hidden';
                                rightSidebar.style.opacity = '0';
                                rightSidebar.style.pointerEvents = 'none';
                                rightSidebar.style.display = 'none';
                                console.log('âœ… Sidebar forcefully hidden after page load');
                            }

                            if (appContainer) {
                                // Ensure app container is not expanded
                                appContainer.classList.remove('sidebar-open');
                                appContainer.classList.add('sidebar-closed');
                                console.log('âœ… App container set to sidebar-closed after page load');
                            }
                        }, 200); // Slightly longer delay to ensure everything is loaded
                    });
                    document.addEventListener('DOMContentLoaded', function () {
                        // Initialize modal cleanup to prevent stuck overlays
                        initializeModalCleanup();
                        initMessageBoxes();
                        loadNotes();
                        loadTemplates();
                        loadDocuments(); // Load common documents on page load
                        loadTicketClaimDocs(); // Load claim documents on main ticket page
                        setupStatusDropdown();
                        setupAttachmentHandlers(); // Setup attachment handling
                        setupQuickResponseDropdown(); // Setup quick response dropdown
                        initializeStatusButton(); // Initialize status button styling

                        // ===== VEHICLE & CLAIM MODAL EVENT LISTENERS =====
                        const editVehicleBtn = document.getElementById('editVehicleInfoBtn');
                        if (editVehicleBtn) {
                            editVehicleBtn.addEventListener('click', openVehicleClaimModal);
                        }

                        const closeVehicleClaimBtn = document.getElementById('closeVehicleClaimModal');
                        if (closeVehicleClaimBtn) {
                            closeVehicleClaimBtn.addEventListener('click', () => closeModal('vehicleClaimModal'));
                        }

                        const cancelVehicleClaimBtn = document.getElementById('cancelVehicleClaim');
                        if (cancelVehicleClaimBtn) {
                            cancelVehicleClaimBtn.addEventListener('click', () => closeModal('vehicleClaimModal'));
                        }

                        const saveVehicleClaimBtn = document.getElementById('saveVehicleClaim');
                        if (saveVehicleClaimBtn) {
                            saveVehicleClaimBtn.addEventListener('click', saveVehicleClaimInfo);
                        }

                        const uploadClaimDocBtn = document.getElementById('uploadClaimDocBtn');
                        if (uploadClaimDocBtn) {
                            uploadClaimDocBtn.addEventListener('click', uploadClaimDocument);
                        }

                        // Make upload zone clickable to trigger file input
                        const uploadZone = document.querySelector('#vehicleClaimModal .upload-zone');
                        const claimFileInput = document.getElementById('claimDocumentFile');

                        if (uploadZone && claimFileInput) {
                            // Style the upload zone for clickability
                            uploadZone.style.cursor = 'pointer';

                            // Click on zone triggers file input
                            uploadZone.addEventListener('click', function (e) {
                                e.preventDefault();
                                claimFileInput.click();
                            });

                            // Show selected file name
                            claimFileInput.addEventListener('change', function () {
                                const files = this.files;
                                if (files.length > 0) {
                                    const fileNames = Array.from(files).map(f => f.name).join(', ');
                                    // Update the upload zone text to show selected files
                                    const textSpan = uploadZone.querySelector('span:first-of-type');
                                    if (textSpan) {
                                        textSpan.textContent = files.length === 1 ? files[0].name : `${files.length} files selected`;
                                        textSpan.style.color = '#10b981'; // Green color for success
                                    }
                                }
                            });
                        }

                        // Initialize fixed-width layout for consistent appearance across screen sizes
                        adjustLayoutForScreenSize();

                        // Initialize sidebar functionality
                        initializeSidebarToggle();

                        // CRITICAL FIX: Ensure sidebar is hidden on page load
                        setTimeout(() => {
                            const rightSidebar = document.querySelector('.right-sidebar');
                            const appContainer = document.querySelector('.app-container');

                            if (rightSidebar) {
                                // Force hide sidebar on page load
                                rightSidebar.classList.remove('sidebar-open', 'ultra-wide-open', 'mobile-open');
                                rightSidebar.style.transform = 'translateX(200%)';
                                rightSidebar.style.visibility = 'hidden';
                                rightSidebar.style.opacity = '0';
                                rightSidebar.style.pointerEvents = 'none';
                                console.log('âœ… Sidebar forcefully hidden on page load');
                            }

                            if (appContainer) {
                                // Ensure app container is not expanded
                                appContainer.classList.remove('sidebar-open');
                                appContainer.classList.add('sidebar-closed');
                                console.log('âœ… App container set to sidebar-closed on page load');
                            }
                        }, 100); // Small delay to ensure DOM is fully ready

                        // Add note button
                        document.getElementById('addNoteBtn').addEventListener('click', function () {
                            document.getElementById('saveNote').removeAttribute('data-note-index');
                            document.getElementById('noteTitle').value = '';
                            document.getElementById('noteContent').value = '';
                            openModal('noteModal');
                        });

                        // Save note button
                        document.getElementById('saveNote').addEventListener('click', saveNote);

                        // Note modal buttons
                        document.getElementById('closeNoteModal').addEventListener('click', () => closeModal('noteModal'));
                        document.getElementById('cancelNote').addEventListener('click', () => closeModal('noteModal'));

                        // Add template button
                        document.getElementById('addTemplateBtn').addEventListener('click', () => editTemplate());

                        // Edit template modal buttons
                        document.getElementById('closeEditTemplateModal').addEventListener('click', () => closeModal('editTemplateModal'));
                        document.getElementById('cancelEditTemplate').addEventListener('click', () => closeModal('editTemplateModal'));
                        document.getElementById('saveTemplate').addEventListener('click', saveTemplate);
                        document.getElementById('deleteTemplate').addEventListener('click', deleteTemplate);

                        // Document Modal
                        const addDocumentBtn = document.getElementById('addDocumentBtn');

                        const closeDocumentModal = document.getElementById('closeDocumentModal');
                        const cancelDocumentBtn = document.getElementById('cancelDocument');
                        const saveDocumentBtn = document.getElementById('saveDocument');
                        const deleteDocumentBtn = document.getElementById('deleteDocument');

                        if (addDocumentBtn) {
                            addDocumentBtn.addEventListener('click', () => {
                                document.getElementById('documentName').value = '';
                                document.getElementById('documentType').value = 'form';
                                document.getElementById('documentFile').value = '';
                                document.getElementById('selectedFileName').textContent = 'No file selected';
                                document.getElementById('documentDescription').value = '';
                                document.getElementById('documentModalTitle').textContent = 'Add New Document';
                                document.getElementById('deleteDocument').classList.add('hidden');
                                document.getElementById('saveDocument').removeAttribute('data-document-id');
                                openModal('documentModal');
                            });
                        }



                        if (closeDocumentModal) {
                            closeDocumentModal.addEventListener('click', () => closeModal('documentModal'));
                        }
                        if (cancelDocumentBtn) {
                            cancelDocumentBtn.addEventListener('click', () => closeModal('documentModal'));
                        }

                        if (saveDocumentBtn) {
                            saveDocumentBtn.addEventListener('click', saveDocument);
                        }

                        if (deleteDocumentBtn) {
                            deleteDocumentBtn.addEventListener('click', () => {
                                const documentId = document.getElementById('saveDocument').getAttribute('data-document-id');
                                if (documentId) {
                                    deleteDocument(documentId);
                                } else {
                                    showNotification('No document selected for deletion', 'error');
                                }
                            });
                        }

                        // Handle file input change event
                        document.getElementById('documentFile').addEventListener('change', function () {
                            const fileName = this.files.length > 0 ? this.files[0].name : 'No file selected';
                            document.getElementById('selectedFileName').textContent = fileName;
                        });

                        // Close Ticket Button functionality (following the same pattern as forward/takeover)
                        const closeResolvedBtn = document.getElementById('closeResolvedBtn');
                        const cancelCloseBtn = document.getElementById('cancelClose');
                        const confirmCloseBtn = document.getElementById('confirmClose');

                        if (closeResolvedBtn) {
                            closeResolvedBtn.addEventListener('click', () => {
                                console.log('ðŸ”’ Close button clicked');
                                openModal('confirmModal');
                            });
                        }

                        if (cancelCloseBtn) {
                            cancelCloseBtn.addEventListener('click', () => closeModal('confirmModal'));
                        }

                        if (confirmCloseBtn) {
                            confirmCloseBtn.addEventListener('click', async () => {
                                console.log('ðŸš€ Close confirmation clicked');

                                try {
                                    // Show loading state
                                    confirmCloseBtn.disabled = true;
                                    confirmCloseBtn.innerHTML = 'â³ Closing...';

                                    const response = await fetch(`/api/tickets/{{ ticket.ticket_id }}/close`, {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/json',
                                            'Accept': 'application/json'
                                        }
                                    });

                                    const data = await response.json();
                                    console.log('Debug: Response status:', response.status);
                                    console.log('Debug: Response data:', data);

                                    if (!response.ok) {
                                        throw new Error(data.message || 'Failed to close ticket');
                                    }

                                    // Use backend message or default (same pattern as takeover)
                                    const successMessage = data.message || 'âœ… Ticket closed successfully!';
                                    showNotification(successMessage, 'success');

                                    // SUCCESS STATE: Show success button state before reload
                                    confirmCloseBtn.disabled = false;
                                    confirmCloseBtn.innerHTML = 'âœ… Ticket Closed!';
                                    confirmCloseBtn.style.backgroundColor = '#dcfce7';
                                    confirmCloseBtn.style.color = '#166534';

                                    closeModal('confirmModal');

                                    // Update UI similar to takeover button
                                    setTimeout(() => {
                                        window.location.reload();
                                    }, 1500);

                                } catch (error) {
                                    console.error('âŒ Error closing ticket:', error);
                                    showNotification(error.message || 'Failed to close ticket', 'error');

                                    // Reset button state
                                    confirmCloseBtn.disabled = false;
                                    confirmCloseBtn.innerHTML = 'Confirm Close';
                                }
                            });
                        }

                        // Message Modal
                        const closeMessageModal = document.getElementById('closeMessageModal');
                        if (closeMessageModal) {
                            closeMessageModal.addEventListener('click', () => closeModal('messageModal'));
                        }

                        // Assignment Modal Variables
                        const assignModal = document.getElementById('assignModal');
                        const assignModalTitle = document.getElementById('assignModalTitle');
                        const closeAssignModal = document.getElementById('closeAssignModal');
                        const cancelAssign = document.getElementById('cancelAssign');
                        const confirmAssign = document.getElementById('confirmAssign');
                        const assignMemberSelect = document.getElementById('assignMemberSelect');
                        const forwardNotesContainer = document.getElementById('forwardNotesContainer');
                        const assignNotes = document.getElementById('assignNotes');
                        const ticketId = '{{ ticket.ticket_id }}';
                        const currentUserId = "{{ session.member_id }}";

                        // Take Over Button - FIXED with proper error recovery
                        const takeOverBtn = document.getElementById('takeOverBtn');
                        if (takeOverBtn) {
                            takeOverBtn.addEventListener('click', async function () {
                                // Prevent double clicks
                                takeOverBtn.disabled = true;
                                const originalText = takeOverBtn.innerHTML;
                                takeOverBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-1"></i> Taking Over...';

                                // ALWAYS reset button after 15 seconds as safety fallback
                                const safetyTimeout = setTimeout(() => {
                                    console.log('ðŸ”„ SAFETY TIMEOUT: Resetting button after 15 seconds');
                                    takeOverBtn.disabled = false;
                                    takeOverBtn.innerHTML = originalText;
                                    showNotification('Takeover may have completed. Please refresh the page to check.', 'warning');
                                }, 15000);

                                try {
                                    const requestData = {
                                        assigned_to: currentUserId,
                                        note: '',
                                        is_forwarded: false,
                                        forwarded_from: null
                                    };

                                    console.log('ðŸŽ¯ TAKEOVER ATTEMPT:', { ticketId, currentUserId });

                                    const response = await fetch(`/api/tickets/${ticketId}/assign`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify(requestData),
                                        credentials: 'include'
                                    });

                                    const data = await response.json();
                                    console.log('ðŸ” TAKEOVER RESPONSE:', data);

                                    if (response.ok && data.status === 'success') {
                                        clearTimeout(safetyTimeout); // Cancel safety timeout
                                        showNotification('âœ… Ticket taken over successfully!', 'success');

                                        // SUCCESS: Show success state briefly, then reload
                                        takeOverBtn.innerHTML = '<i class="fas fa-check mr-1"></i> Taken Over!';
                                        takeOverBtn.style.backgroundColor = '#dcfce7';
                                        takeOverBtn.style.color = '#166534';

                                        // Simple reload after success
                                        setTimeout(() => {
                                            window.location.reload();
                                        }, 2000);

                                    } else {
                                        clearTimeout(safetyTimeout); // Cancel safety timeout
                                        // Re-enable button on error
                                        takeOverBtn.disabled = false;
                                        takeOverBtn.innerHTML = originalText;
                                        showNotification(data.message || 'Error taking over ticket', 'error');
                                        console.error('âŒ TAKEOVER ERROR:', data);
                                    }
                                } catch (error) {
                                    clearTimeout(safetyTimeout); // Cancel safety timeout
                                    // Re-enable button on exception
                                    takeOverBtn.disabled = false;
                                    takeOverBtn.innerHTML = originalText;
                                    console.error('âŒ TAKEOVER EXCEPTION:', error);
                                    showNotification('Network error while taking over ticket', 'error');
                                }
                            });
                        }

                        // Refer to Tech Director Button - Direct API call
                        const referToTechDirectorBtn = document.getElementById('referToTechDirectorBtn');
                        if (referToTechDirectorBtn) {
                            referToTechDirectorBtn.addEventListener('click', async function () {
                                // Show confirmation dialog
                                if (!confirm('Are you sure you want to refer this ticket to the Technical Director?\n\nThis will:\nâ€¢ Change ticket status to "Referred to Tech Director"\nâ€¢ Send email notification to Tech Director\nâ€¢ Schedule AI-powered reminder via n8n workflow\n\nClick OK to proceed.')) {
                                    return;
                                }

                                // Disable button to prevent double-clicks
                                referToTechDirectorBtn.disabled = true;
                                referToTechDirectorBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-1"></i> Referring...';

                                try {
                                    const response = await fetch(`/api/tickets/${ticketId}/tech-director`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' }
                                    });

                                    const data = await response.json();

                                    if (response.ok && data.status === 'success') {
                                        showNotification(`âœ… Ticket successfully referred to Tech Director!\nðŸš€ Real-time Mode: ${data.real_time_mode ? 'Active' : 'Inactive'}\nðŸ”„ Webhook: ${data.webhook_queued ? 'Queued' : 'Failed'}\nðŸ“§ Email: ${data.email_sent ? 'Sent' : 'Failed'}`, 'success');

                                        // Log the response for debugging
                                        console.log('ðŸŽ¯ Tech Director Referral Success (Real-time):', data);

                                        // REAL-TIME STATUS UPDATE: Update the ticket status to "Referred to Tech Director"
                                        const newStatus = 'Referred to Tech Director';
                                        const oldStatus = '{{ ticket.status }}';
                                        const newStatusClass = newStatus.toLowerCase().replace(/ /g, '-').replace(/â€“/g, '');

                                        // Update ALL status badges on the page
                                        const allStatusBadges = document.querySelectorAll('[class*="status-"]');
                                        allStatusBadges.forEach(badge => {
                                            if (badge.textContent === oldStatus || badge.textContent.includes(oldStatus)) {
                                                badge.textContent = newStatus;
                                                badge.className = `px-3 py-1 text-xs rounded-lg font-medium status-${newStatusClass}`;
                                            }
                                        });

                                        // Update status dropdown button text
                                        const statusDisplay = document.getElementById('currentStatusDisplay');
                                        if (statusDisplay) {
                                            statusDisplay.textContent = newStatus;
                                        }

                                        // Update the status dropdown button styling
                                        const statusDropdownBtn = document.getElementById('statusDropdownBtn');
                                        if (statusDropdownBtn) {
                                            statusDropdownBtn.className = statusDropdownBtn.className.replace(/status-\S+/g, '');
                                            statusDropdownBtn.classList.add(`status-${newStatusClass}`);
                                        }

                                        // Update any other status-related elements
                                        const statusElements = document.querySelectorAll('[data-status]');
                                        statusElements.forEach(element => {
                                            if (element.textContent === oldStatus) {
                                                element.textContent = newStatus;
                                            }
                                        });

                                        // Update the Refer to Tech Director button to show "Currently with Tech Director"
                                        referToTechDirectorBtn.disabled = false;
                                        referToTechDirectorBtn.innerHTML = '<i class="fas fa-check-circle mr-1 text-green-600"></i> Successfully Referred!';
                                        referToTechDirectorBtn.classList.add('bg-green-100', 'text-green-800');
                                        referToTechDirectorBtn.classList.remove('bg-orange-100', 'text-orange-800');

                                        // After 3 seconds, change to "Currently with Tech Director" state
                                        setTimeout(() => {
                                            referToTechDirectorBtn.innerHTML = '<i class="fas fa-user-cog mr-1"></i> Currently with Tech Director';
                                            referToTechDirectorBtn.classList.remove('bg-green-100', 'text-green-800');
                                            referToTechDirectorBtn.classList.add('bg-orange-50', 'text-orange-700', 'border', 'border-orange-200');
                                            referToTechDirectorBtn.disabled = true;
                                        }, 3000);
                                    } else {
                                        showNotification(data.message || 'Error referring ticket to Tech Director', 'error');

                                        // Re-enable button on error
                                        referToTechDirectorBtn.disabled = false;
                                        referToTechDirectorBtn.innerHTML = '<i class="fas fa-user-cog mr-1"></i> Refer to Tech Director';
                                    }
                                } catch (error) {
                                    console.error('ðŸš¨ Tech Director Referral Error:', error);
                                    showNotification('An error occurred while referring ticket to Tech Director', 'error');

                                    // Re-enable button on error
                                    referToTechDirectorBtn.disabled = false;
                                    referToTechDirectorBtn.innerHTML = '<i class="fas fa-user-cog mr-1"></i> Refer to Tech Director';
                                }
                            });
                        }

                        // Forward Button - DUPLICATE LISTENER REMOVED
                        // This was conflicting with the main forward modal listener at line ~9294
                        // const forwardBtn = document.getElementById('forwardBtn');
                        // if (forwardBtn) { ... }

                        // Close assign modal
                        function closeAssignModalFunc() {
                            assignModal.classList.remove('active');
                        }

                        if (closeAssignModal) closeAssignModal.addEventListener('click', closeAssignModalFunc);
                        if (cancelAssign) cancelAssign.addEventListener('click', closeAssignModalFunc);

                        // Confirm assignment (only for forwarding - Take Over bypasses modal)
                        if (confirmAssign) {
                            confirmAssign.addEventListener('click', async function () {
                                const memberId = assignMemberSelect.value;
                                const notes = assignNotes.value;

                                if (!memberId) {
                                    showNotification('Please select a member to forward to', 'error');
                                    return;
                                }

                                try {
                                    const response = await fetch(`/api/tickets/${ticketId}/assign`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({
                                            assigned_to: memberId,
                                            note: notes,
                                            is_forwarded: true,
                                            forwarded_from: currentUserId
                                        }),
                                        credentials: 'include'
                                    });

                                    const data = await response.json();
                                    if (response.ok && data.status === 'success') {
                                        // SMOOTH: Update assignment display instead of full reload
                                        const takeOverBtn = document.getElementById('takeOverBtn');
                                        if (takeOverBtn) {
                                            takeOverBtn.style.display = 'none';
                                        }

                                        // Add assignment badge
                                        const assignmentArea = document.querySelector('.assignment-status-area') || document.querySelector('.px-3.py-1.rounded-lg');
                                        if (assignmentArea) {
                                            assignmentArea.innerHTML = `
                                    <div class="px-3 py-1 rounded-lg bg-blue-50 text-blue-700 border border-blue-200">
                                        <i class="fas fa-share mr-1"></i> Forwarded to ${assignMemberSelect.options[assignMemberSelect.selectedIndex].text}
                                        <span class="text-xs opacity-75 ml-1">(just now)</span>
                                    </div>
                                `;
                                        }

                                        closeModal('assignModal');
                                        showNotification('Ticket forwarded successfully!', 'success');
                                    } else {
                                        showNotification(data.message || 'Error forwarding ticket', 'error');
                                    }
                                } catch (error) {
                                    console.error('Error:', error);
                                    showNotification('An error occurred while forwarding ticket', 'error');
                                }
                            });
                        }

                        // Importance Button
                        const importantBtn = document.getElementById('importantBtn');
                        if (importantBtn) {
                            importantBtn.addEventListener('click', async function () {
                                try {
                                    const response = await fetch(`/api/tickets/{{ ticket.ticket_id }}/important`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' }
                                    });

                                    const data = await response.json();
                                    if (response.ok && data.status === 'success') {
                                        importantBtn.classList.toggle('important');
                                        const icon = importantBtn.querySelector('.star-icon i');

                                        if (icon.classList.contains('far')) {
                                            // Change from empty star to filled star
                                            icon.classList.remove('far');
                                            icon.classList.add('fas');
                                            showNotification('Ticket marked as important');
                                        } else {
                                            // Change from filled star to empty star
                                            icon.classList.remove('fas');
                                            icon.classList.add('far');
                                            showNotification('Ticket importance removed');
                                        }
                                    } else {
                                        showNotification(data.message || 'Error toggling important status', 'error');
                                    }
                                } catch (error) {
                                    console.error('Error:', error);
                                    showNotification('An error occurred while updating ticket status', 'error');
                                }
                            });
                        }



                        // Reply Form - COMPLETELY PREVENT MULTIPLE SUBMISSIONS
                        const replyForm = document.getElementById('replyForm');
                        if (replyForm) {
                            // Global flag to prevent multiple submissions
                            let isSubmitting = false;

                            // Remove ALL existing event listeners by replacing the form
                            const newReplyForm = replyForm.cloneNode(true);
                            replyForm.parentNode.replaceChild(newReplyForm, replyForm);

                            // Get fresh references after replacement
                            const freshForm = document.getElementById('replyForm');
                            const sendBtn = document.getElementById('sendBtn');
                            const responseTextarea = document.querySelector('textarea[name="response"]');

                            // MESSAGE PRESERVATION: Save and restore message content
                            const ticketId = '{{ ticket.ticket_id|e }}';
                            const messageKey = 'ticket_' + ticketId + '_message';

                            // Restore saved message on page load
                            const savedMessage = localStorage.getItem(messageKey);
                            if (savedMessage && !responseTextarea.value.trim()) {
                                responseTextarea.value = savedMessage;
                            }

                            // Save message as user types
                            const responseEditor = document.getElementById('response_editor');

                            if (responseEditor) {
                                // Initialize from textarea if exists
                                if (savedMessage && !responseEditor.innerText.trim()) {
                                    responseEditor.innerText = savedMessage;
                                }

                                responseEditor.addEventListener('input', function () {
                                    // Sync to hidden textarea
                                    responseTextarea.value = this.innerText;

                                    if (this.innerText.trim()) {
                                        localStorage.setItem(messageKey, this.innerText);
                                    } else {
                                        localStorage.removeItem(messageKey);
                                    }
                                });
                            } else {
                                responseTextarea.addEventListener('input', function () {
                                    if (this.value.trim()) {
                                        localStorage.setItem(messageKey, this.value);
                                    } else {
                                        localStorage.removeItem(messageKey);
                                    }
                                });
                            }

                            // SINGLE event listener with aggressive anti-spam protection
                            freshForm.addEventListener('submit', async function (e) {
                                e.preventDefault();
                                e.stopPropagation();



                                // ABSOLUTE PREVENTION OF MULTIPLE SUBMISSIONS
                                if (isSubmitting || sendBtn.disabled) {

                                    return false;
                                }

                                // Validate input
                                if (!responseTextarea.value.trim()) {
                                    alert('Please enter a response');
                                    return false;
                                }

                                // SET GLOBAL FLAG AND DISABLE EVERYTHING
                                isSubmitting = true;
                                sendBtn.disabled = true;
                                sendBtn.style.pointerEvents = 'none';
                                sendBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i> Sending...';



                                try {
                                    // Sync contenteditable to textarea just before submitting
                                    const responseEditor = document.getElementById('response_editor');
                                    if (responseEditor) {
                                        responseTextarea.value = responseEditor.innerText;
                                    }

                                    // Create FormData object to handle both text and file attachments
                                    const formData = new FormData();
                                    formData.append('response', responseTextarea.value);

                                    // ENHANCED: Add files from the new drag & drop attachment system
                                    if (window.currentAttachments && window.currentAttachments.length > 0) {
                                        console.log(`ðŸ“Ž Processing ${window.currentAttachments.length} enhanced attachments`);

                                        // Process enhanced attachments with proper file handling
                                        for (let i = 0; i < window.currentAttachments.length; i++) {
                                            const attachment = window.currentAttachments[i];

                                            if (attachment.type === 'file') {
                                                // Handle uploaded files - they have actual file data
                                                formData.append('response_attachments', attachment.file);
                                                console.log(`ðŸ“Ž Added file attachment: ${attachment.name}`);
                                            } else if (attachment.type === 'common_document') {
                                                // ðŸš€ ENHANCED: Use already-fetched file data from drag & drop
                                                if (attachment.file && attachment.file.size > 0) {
                                                    // File data was already fetched during drag & drop
                                                    formData.append('response_attachments', attachment.file);
                                                    console.log(`âœ… Using pre-fetched file data for common document: ${attachment.name} (Size: ${attachment.file.size} bytes)`);
                                                } else {
                                                    // Fallback: fetch file data now (shouldn't happen with enhanced system)
                                                    console.log(`ðŸ”„ Fallback: Fetching file data for common document: ${attachment.name} (ID: ${attachment.documentId})`);
                                                    try {
                                                        const response = await fetch(`/api/common-documents/${attachment.documentId}/download`);
                                                        if (response.ok) {
                                                            const blob = await response.blob();
                                                            const file = new File([blob], attachment.name, {
                                                                type: attachment.fileType || 'application/octet-stream'
                                                            });
                                                            formData.append('response_attachments', file);
                                                            console.log(`âœ… Successfully converted common document to file: ${attachment.name}`);
                                                        } else {
                                                            console.error(`âŒ Failed to fetch common document: ${attachment.name}`);
                                                            // Fallback: add as common document reference
                                                            formData.append(`common_document_${i}`, attachment.documentId);
                                                            formData.append(`common_document_name_${i}`, attachment.name);
                                                        }
                                                    } catch (error) {
                                                        console.error(`âŒ Error processing common document ${attachment.name}:`, error);
                                                        // Fallback: add as common document reference
                                                        formData.append(`common_document_${i}`, attachment.documentId);
                                                        formData.append(`common_document_name_${i}`, attachment.name);
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    // ENHANCED: Only use the new drag & drop system - remove legacy conflicts
                                    // The new system handles both files and common documents seamlessly

                                    // Debug logging to see what's being sent
                                    console.log('ðŸ” DEBUG: Enhanced attachments to be sent:', window.currentAttachments);

                                    // Log the final FormData contents
                                    for (let [key, value] of formData.entries()) {
                                        console.log(`ðŸ“‹ FormData: ${key} = ${value}`);
                                    }

                                    // Legacy attachedFiles system removed - enhanced system handles everything

                                    // Add common documents as attachments
                                    const commonDocumentPreview = document.getElementById('commonDocumentPreview');
                                    if (commonDocumentPreview && commonDocumentPreview.children.length > 0) {


                                        for (let i = 0; i < commonDocumentPreview.children.length; i++) {
                                            const docItem = commonDocumentPreview.children[i];
                                            const documentId = docItem.dataset.documentId;
                                            const documentName = docItem.querySelector('span').textContent;



                                            if (documentId) {
                                                // Add document reference to form data in the format expected by backend
                                                formData.append(`common_document_${i}`, documentId);
                                                formData.append(`common_document_name_${i}`, documentName);

                                                // ENHANCED: Add all document metadata to form data for debugging
                                                if (docItem.dataset.documentType) formData.append(`common_document_type_${i}`, docItem.dataset.documentType);
                                                if (docItem.dataset.documentDescription) formData.append(`common_document_description_${i}`, docItem.dataset.documentDescription);
                                                if (docItem.dataset.documentFileName) formData.append(`common_document_filename_${i}`, docItem.dataset.documentFileName);
                                                if (docItem.dataset.documentFileSize) formData.append(`common_document_filesize_${i}`, docItem.dataset.documentFileSize);
                                                if (docItem.dataset.documentFilePath) formData.append(`common_document_filepath_${i}`, docItem.dataset.documentFilePath);
                                                if (docItem.dataset.documentCreatedAt) formData.append(`common_document_created_${i}`, docItem.dataset.documentCreatedAt);
                                                if (docItem.dataset.documentUpdatedAt) formData.append(`common_document_updated_${i}`, docItem.dataset.documentUpdatedAt);
                                                if (docItem.dataset.documentIsActive) formData.append(`common_document_active_${i}`, docItem.dataset.documentIsActive);
                                                if (docItem.dataset.arrayIndex) formData.append(`common_document_arrayindex_${i}`, docItem.dataset.arrayIndex);


                                            }
                                        }

                                    } else {

                                    }



                                    // Send to main API endpoint
                                    const response = await fetch('/api/tickets/' + ticketId + '/reply', {
                                        method: 'POST',
                                        body: formData  // Use FormData instead of URLSearchParams
                                    });



                                    // Also send to n8n webhook (parallel processing)
                                    try {
                                        // âœ… FIXED: Check if ticket was created from email using CORRECT message_id field
                                        const originalMessageId = '{{ ticket.message_id|default("", true) }}';
                                        const creationMethod = '{{ ticket.creation_method|default("", true) }}';

                                        // Email ticket detection: check if message_id exists and is NOT a system-generated ID
                                        const isRealEmailMessageId = originalMessageId && originalMessageId.trim() && !originalMessageId.startsWith('msg-');
                                        const isEmailTicket = creationMethod === 'email' || isRealEmailMessageId;

                                        // âœ… PROCESS ATTACHMENTS for webhook payload
                                        const attachmentData = [];
                                        let totalFiles = 0;

                                        // ENHANCED: Process new drag & drop attachments first
                                        if (window.currentAttachments && window.currentAttachments.length > 0) {
                                            console.log(`ðŸ“Ž Processing ${window.currentAttachments.length} enhanced attachments for webhook`);

                                            for (let i = 0; i < window.currentAttachments.length; i++) {
                                                const attachment = window.currentAttachments[i];

                                                if (attachment.type === 'file') {
                                                    // Process uploaded files
                                                    try {
                                                        const base64Data = await new Promise((resolve, reject) => {
                                                            const reader = new FileReader();
                                                            reader.onload = () => {
                                                                const base64 = reader.result.split(',')[1];
                                                                resolve(base64);
                                                            };
                                                            reader.onerror = reject;
                                                            reader.readAsDataURL(attachment.file);
                                                        });

                                                        attachmentData.push({
                                                            fileName: attachment.name,
                                                            fileData: base64Data,
                                                            size: attachment.size,
                                                            type: attachment.fileType,
                                                            isWarranty: attachment.name.toLowerCase().includes('warranty'),
                                                            source: 'enhanced_drag_drop'
                                                        });
                                                        totalFiles++;
                                                        console.log(`âœ… Enhanced file attachment: ${attachment.name} (${attachment.size} bytes)`);
                                                    } catch (error) {
                                                        console.error(`âŒ Failed to encode enhanced attachment ${attachment.name}:`, error);
                                                    }
                                                } else if (attachment.type === 'common_document') {
                                                    // Process common document references
                                                    attachmentData.push({
                                                        fileName: attachment.name,
                                                        documentId: attachment.documentId,
                                                        size: attachment.size,
                                                        type: attachment.fileType,
                                                        isWarranty: false,
                                                        source: 'enhanced_common_document',
                                                        isCommonDocument: true
                                                    });
                                                    totalFiles++;
                                                    console.log(`âœ… Enhanced common document: ${attachment.name} (ID: ${attachment.documentId})`);
                                                }
                                            }
                                        }

                                        // Process file input attachments (legacy support)
                                        if (fileInput && fileInput.files.length > 0) {

                                            totalFiles += fileInput.files.length;

                                            for (let i = 0; i < fileInput.files.length; i++) {
                                                const file = fileInput.files[i];
                                                try {
                                                    // Convert file to base64 for webhook payload
                                                    const base64Data = await new Promise((resolve, reject) => {
                                                        const reader = new FileReader();
                                                        reader.onload = () => {
                                                            // Remove data:mime/type;base64, prefix
                                                            const base64 = reader.result.split(',')[1];
                                                            resolve(base64);
                                                        };
                                                        reader.onerror = reject;
                                                        reader.readAsDataURL(file);
                                                    });

                                                    attachmentData.push({
                                                        fileName: file.name,
                                                        fileData: base64Data,
                                                        size: file.size,
                                                        type: file.type,
                                                        isWarranty: file.name.toLowerCase().includes('warranty')
                                                    });
                                                    console.log(`âœ… Encoded attachment: ${file.name} (${file.size} bytes)`);
                                                } catch (error) {
                                                    console.error(`âŒ Failed to encode attachment ${file.name}:`, error);
                                                }
                                            }
                                        }

                                        // ðŸš€ ENHANCED: Process attached files from enhanced attachment system
                                        if (window.currentAttachments && window.currentAttachments.length > 0) {
                                            console.log(`ðŸ“Ž Processing ${window.currentAttachments.length} enhanced attachments for webhook`);

                                            for (let i = 0; i < window.currentAttachments.length; i++) {
                                                const attachment = window.currentAttachments[i];

                                                if (attachment.type === 'file' && attachment.file) {
                                                    // Handle uploaded files
                                                    try {
                                                        const base64Data = await new Promise((resolve, reject) => {
                                                            const reader = new FileReader();
                                                            reader.onload = () => {
                                                                const base64 = reader.result.split(',')[1];
                                                                resolve(base64);
                                                            };
                                                            reader.onerror = reject;
                                                            reader.readAsDataURL(attachment.file);
                                                        });

                                                        attachmentData.push({
                                                            fileName: attachment.name,
                                                            fileData: base64Data,  // ðŸš€ CRITICAL: This is what n8n expects
                                                            size: attachment.size,
                                                            type: attachment.fileType,
                                                            isWarranty: attachment.name.toLowerCase().includes('warranty')
                                                        });
                                                        totalFiles++;
                                                        console.log(`âœ… Encoded uploaded file: ${attachment.name} (${attachment.size} bytes)`);
                                                    } catch (error) {
                                                        console.error(`âŒ Failed to encode uploaded file ${attachment.name}:`, error);
                                                    }
                                                } else if (attachment.type === 'common_document' && attachment.file) {
                                                    // Handle common documents with file data
                                                    try {
                                                        const base64Data = await new Promise((resolve, reject) => {
                                                            const reader = new FileReader();
                                                            reader.onload = () => {
                                                                const base64 = reader.result.split(',')[1];
                                                                resolve(base64);
                                                            };
                                                            reader.onerror = reject;
                                                            reader.readAsDataURL(attachment.file);
                                                        });

                                                        attachmentData.push({
                                                            fileName: attachment.name,
                                                            fileData: base64Data,  // ðŸš€ CRITICAL: This is what n8n expects
                                                            size: attachment.size,
                                                            type: attachment.fileType,
                                                            isWarranty: attachment.name.toLowerCase().includes('warranty'),
                                                            isCommonDocument: true,
                                                            documentId: attachment.documentId
                                                        });
                                                        totalFiles++;
                                                        console.log(`âœ… Encoded common document: ${attachment.name} (${attachment.size} bytes)`);
                                                    } catch (error) {
                                                        console.error(`âŒ Failed to encode common document ${attachment.name}:`, error);
                                                    }
                                                }
                                            }
                                        }

                                        // Process common documents for webhook
                                        const commonDocumentPreview = document.getElementById('commonDocumentPreview');
                                        let commonDocData = [];
                                        if (commonDocumentPreview && commonDocumentPreview.children.length > 0) {
                                            console.log('ðŸ“„ Processing common documents for webhook...');
                                            commonDocumentPreview.querySelectorAll('[data-document-id]').forEach((item, index) => {
                                                const docId = item.dataset.documentId;
                                                const docName = item.querySelector('span').textContent;

                                                // ENHANCED DEBUGGING: Log all available data for webhook
                                                console.log(`ðŸ“„ Webhook Common Document ${index + 1}:`);
                                                console.log('  - Document ID:', docId);
                                                console.log('  - Document Name:', docName);
                                                console.log('  - Document Type:', item.dataset.documentType);
                                                console.log('  - Document Description:', item.dataset.documentDescription);
                                                console.log('  - Document File Name:', item.dataset.documentFileName);
                                                console.log('  - Document File Size:', item.dataset.documentFileSize);
                                                console.log('  - Document File Path:', item.dataset.documentFilePath);
                                                console.log('  - Document Created At:', item.dataset.documentCreatedAt);
                                                console.log('  - Document Updated At:', item.dataset.documentUpdatedAt);
                                                console.log('  - Document Is Active:', item.dataset.documentIsActive);
                                                console.log('  - Array Index:', item.dataset.arrayIndex);
                                                console.log('  - Full dataset:', item.dataset);

                                                commonDocData.push({
                                                    document_id: docId,
                                                    document_name: docName,
                                                    type: 'common_document',
                                                    // ENHANCED: Include all metadata for webhook debugging
                                                    document_type: item.dataset.documentType,
                                                    document_description: item.dataset.documentDescription,
                                                    document_filename: item.dataset.documentFileName,
                                                    document_filesize: item.dataset.documentFileSize,
                                                    document_filepath: item.dataset.documentFilePath,
                                                    document_created_at: item.dataset.documentCreatedAt,
                                                    document_updated_at: item.dataset.documentUpdatedAt,
                                                    document_is_active: item.dataset.documentIsActive,
                                                    array_index: item.dataset.arrayIndex
                                                });
                                            });
                                            console.log('ðŸ“„ Common documents prepared for webhook:', commonDocData);
                                        }

                                        // Handle custom @VHC_Link tag replacement for emails
                                        let html_message = responseTextarea.value.replace(/\n/g, '<br>\n');
                                        let message_plain = responseTextarea.value;
                                        const ticket_vhc_link = '{{ ticket.vhc_link|default("", true) }}';

                                        if (ticket_vhc_link) {
                                            const html_link = `<a href="${ticket_vhc_link}" target="_blank" style="color: #4f46e5; font-weight: 500; text-decoration: underline;">Vehicle Health Check â€” click here</a>`;
                                            const regex = /(@VHC_Link|\[VHC_LINK\])/gi;
                                            html_message = html_message.replace(regex, html_link);
                                            message_plain = message_plain.replace(regex, `Vehicle Health Check: ${ticket_vhc_link}`);
                                        }

                                        const webhookData = {
                                            ticket_id: '{{ ticket.ticket_id }}',
                                            response_text: message_plain,
                                            replyMessage: html_message, // ðŸš€ ADDED: sent as HTML to support VHC Links
                                            html_message: html_message, // Reference HTML
                                            timestamp: new Date().toISOString(),
                                            user_id: '{{ session.member_id if session.member_id else "unknown" }}',
                                            ticket_subject: '{{ ticket.subject|default("", true) }}',
                                            subject: '{{ ticket.subject|default("", true) }}', // ðŸš€ ADDED: subject field for n8n compatibility
                                            ticket_status: '{{ ticket.status|default("", true) }}',
                                            customer_email: '{{ ticket.email|default("", true) }}',
                                            customer_name: '{{ ticket.name|default("", true) }}',
                                            priority: '{{ ticket.Priority|default("", true) }}',
                                            has_attachments: totalFiles > 0, // âœ… Updated to reflect actual file count
                                            attachments: attachmentData, // âœ… Include actual attachment data
                                            attachment_count: attachmentData.length, // âœ… Explicit count
                                            has_common_documents: commonDocData.length > 0,
                                            common_documents: commonDocData,
                                            common_document_count: commonDocData.length,
                                            message_id: isRealEmailMessageId ? originalMessageId : false, // Send original email message ID or false
                                            is_email_ticket: isEmailTicket,
                                            creation_method: creationMethod || 'manual',
                                            ticketSource: isEmailTicket ? 'email' : 'manual' // ðŸš€ ADDED: ticketSource field for n8n compatibility
                                        };

                                        console.log('ðŸš€ SENDING TO N8N WEBHOOK:');
                                        console.log('   ðŸ“§ Original Message ID from DB:', originalMessageId);
                                        console.log('   âœ… Is Real Email Message ID:', isRealEmailMessageId);
                                        console.log('   ðŸ“§ Message ID being sent:', webhookData.message_id);
                                        console.log('   ðŸ“© Is Email Ticket:', webhookData.is_email_ticket);
                                        console.log('   ðŸ”§ Creation Method:', webhookData.creation_method);
                                        console.log('   ðŸ“Ž Total Files Found:', totalFiles);
                                        console.log('   ðŸ“Ž Attachments Processed:', webhookData.attachment_count);
                                        console.log('   ðŸ“Ž Has Attachments:', webhookData.has_attachments);
                                        if (webhookData.attachments && webhookData.attachments.length > 0) {
                                            webhookData.attachments.forEach((att, index) => {
                                                console.log(`   ðŸ“Ž Attachment ${index + 1}: ${att.fileName} (${att.size} bytes, ${att.type})`);
                                                console.log(`   ðŸ“Ž FileData Length: ${att.fileData ? att.fileData.length : 0} chars`);
                                                console.log(`   ðŸ“Ž Has FileData: ${att.fileData ? 'YES' : 'NO'}`);
                                            });
                                        }
                                        console.log('   ðŸ“„ Has Common Documents:', webhookData.has_common_documents);
                                        console.log('   ðŸ“„ Common Document Count:', webhookData.common_document_count);
                                        if (webhookData.common_documents && webhookData.common_documents.length > 0) {
                                            webhookData.common_documents.forEach((doc, index) => {
                                                console.log(`   ðŸ“„ Common Document ${index + 1}: ${doc.document_name} (ID: ${doc.document_id}, Type: ${doc.document_type})`);
                                            });
                                        }
                                        console.log('   ðŸ“¦ Full Payload:', webhookData);

                                        // ðŸš€ FIXED: Removed frontend webhook call to prevent duplicate webhooks
                                        // Backend already handles webhook triggering when reply is saved
                                        // This prevents automatic replies caused by double webhook firing
                                        console.log('âœ… Skipping frontend webhook - backend will handle webhook triggering');
                                    } catch (webhookError) {
                                        console.error('âŒ WEBHOOK PROCESSING ERROR:', webhookError);
                                        // Don't fail the main process if webhook processing fails
                                    }

                                    if (response.ok) {
                                        const data = await response.json();
                                        console.log('âœ… SUCCESS RESPONSE:', data);

                                        // Clear saved message from localStorage since it was sent successfully
                                        localStorage.removeItem(messageKey);

                                        // Clear form immediately
                                        responseTextarea.value = '';
                                        const responseEditor = document.getElementById('response_editor');
                                        if (responseEditor) responseEditor.innerHTML = '';

                                        // Reset textarea height after clearing
                                        if (typeof window.autoExpandTextarea === 'function') {
                                            window.autoExpandTextarea(responseTextarea);
                                        }

                                        // Clear file input
                                        const fileInput = document.getElementById('response_attachments');
                                        if (fileInput) {
                                            fileInput.value = '';
                                        }

                                        // ðŸš€ REMOVED: Old attachment clearing - enhanced system handles this

                                        // ENHANCED: Clear new drag & drop attachments
                                        if (window.currentAttachments) {
                                            window.currentAttachments = [];
                                            console.log('âœ… Cleared enhanced attachments');
                                        }

                                        // Hide enhanced attachment preview
                                        const enhancedAttachmentPreview = document.getElementById('enhancedAttachmentPreview');
                                        if (enhancedAttachmentPreview) {
                                            enhancedAttachmentPreview.classList.add('hidden');
                                            const attachmentPreviewList = document.getElementById('attachmentPreviewList');
                                            if (attachmentPreviewList) {
                                                attachmentPreviewList.innerHTML = '';
                                            }
                                        }

                                        // Hide attachment preview if visible (legacy support)
                                        const attachmentPreview = document.getElementById('attachmentPreview');
                                        if (attachmentPreview) {
                                            attachmentPreview.innerHTML = '';
                                            attachmentPreview.classList.add('hidden');
                                        }

                                        // Clear common documents
                                        const commonDocumentDropzone = document.getElementById('commonDocumentDropzone');
                                        const commonDocumentPreview = document.getElementById('commonDocumentPreview');
                                        if (commonDocumentDropzone && commonDocumentPreview) {
                                            commonDocumentPreview.innerHTML = '';
                                            commonDocumentDropzone.classList.add('hidden');
                                        }

                                        // Clear processed documents tracking to allow re-adding documents
                                        processedDocuments.clear();
                                        console.log('âœ… Form submitted - cleared processed documents tracking');

                                        // Show success and redirect quickly
                                        showNotification('Reply sent successfully! ðŸ“§', 'success');

                                        // Notify parent window (index page) that a reply was sent
                                        try {
                                            if (window.opener && !window.opener.closed) {
                                                window.opener.postMessage({
                                                    type: 'replySent',
                                                    ticketId: '{{ ticket.ticket_id }}',
                                                    timestamp: Date.now()
                                                }, '*');
                                            }

                                            // Also notify other tabs via localStorage
                                            localStorage.setItem('newReplyAdded', JSON.stringify({
                                                type: 'replySent',
                                                ticketId: '{{ ticket.ticket_id }}',
                                                timestamp: Date.now()
                                            }));

                                            // Clean up localStorage after a short delay
                                            setTimeout(() => {
                                                localStorage.removeItem('newReplyAdded');
                                            }, 5000);
                                        } catch (error) {
                                            console.log('Could not notify parent window:', error);
                                        }

                                        // NO RELOAD - Update UI dynamically
                                        setTimeout(() => {
                                            // Scroll to bottom
                                            const container = document.querySelector('.conversation-container');
                                            if (container) {
                                                container.scrollTop = container.scrollHeight;
                                                window.scrollTo(0, document.body.scrollHeight);
                                            }
                                        }, 100);
                                    } else {
                                        const error = await response.json();
                                        console.error('âŒ API ERROR:', error);
                                        alert('Error: ' + error.message);
                                    }
                                } catch (err) {
                                    console.error('âŒ NETWORK ERROR:', err);
                                    alert('An error occurred while sending the response');
                                } finally {
                                    // Reset flags and button after delay to prevent rapid resubmission
                                    // Keep message in localStorage for retry if sending failed
                                    setTimeout(() => {
                                        isSubmitting = false;
                                        sendBtn.disabled = false;
                                        sendBtn.style.pointerEvents = 'auto';
                                        sendBtn.innerHTML = '<i class="fas fa-paper-plane mr-2"></i> Send Response';
                                        console.log('ðŸ”„ RESET - Ready for next submission');
                                    }, 2000);
                                }

                                return false;
                            }, { once: false });

                            // Additional protection - remove any other submit handlers
                            freshForm.onsubmit = null;

                            console.log('ðŸ”§ REPLY FORM INITIALIZED - Anti-spam protection active');
                        }

                        // Click handler for expanding original message in modal
                        const originalMessage = document.getElementById('originalMessage');
                        if (originalMessage) {
                            originalMessage.addEventListener('click', function (e) {
                                if (e.target.classList.contains('read-more-btn')) return;
                                if (this.classList.contains('truncated')) {
                                    const modalContent = document.getElementById('modalMessageContent');
                                    modalContent.textContent = this.textContent.trim();
                                    openModal('messageModal');
                                }
                            });
                        }

                        // Click handler for expanding reply messages in modal
                        document.querySelectorAll('.reply-message-box').forEach(box => {
                            box.addEventListener('click', function (e) {
                                if (e.target.classList.contains('expand-btn')) return;
                                if (this.classList.contains('truncated')) {
                                    const modalContent = document.getElementById('modalMessageContent');
                                    modalContent.textContent = this.querySelector('.message-content').textContent.trim();
                                    openModal('messageModal');
                                }
                            });
                        });
                    });

                    // Handle file input change event
                    document.getElementById('documentFile').addEventListener('change', function () {
                        const fileName = this.files.length > 0 ? this.files[0].name : 'No file selected';
                        document.getElementById('selectedFileName').textContent = fileName;
                    });

                    // Set up communication with index page
                    function setupIndexPageCommunication() {
                        // Listen for messages from index page
                        window.addEventListener('message', function (event) {
                            if (event.data && event.data.type === 'establishCommunication') {
                                console.log('ðŸ“¡ Communication established with index page');

                                // Send confirmation back
                                try {
                                    if (event.source && !event.source.closed) {
                                        event.source.postMessage({
                                            type: 'communicationEstablished',
                                            ticketId: '{{ ticket.ticket_id }}',
                                            timestamp: Date.now()
                                        }, '*');
                                    }
                                } catch (error) {
                                    console.log('Could not send confirmation to index page');
                                }
                            }
                        });

                        // Notify index page when this page loads
                        try {
                            if (window.opener && !window.opener.closed) {
                                window.opener.postMessage({
                                    type: 'ticketDetailPageLoaded',
                                    ticketId: '{{ ticket.ticket_id }}',
                                    timestamp: Date.now()
                                }, '*');
                            }
                        } catch (error) {
                            console.log('Could not notify index page of load');
                        }
                    }

                    // Initialize communication
                    setupIndexPageCommunication();

                    // Enhanced Response attachment handling with drag & drop
                    function setupAttachmentHandlers() {
                        console.log('Setting up enhanced attachment handlers with drag & drop');
                        const dropzone = document.getElementById('replyDropzone');
                        const fileInput = document.getElementById('response_attachments');
                        const enhancedAttachmentPreview = document.getElementById('enhancedAttachmentPreview');
                        const attachmentPreviewList = document.getElementById('attachmentPreviewList');
                        const replyForm = document.getElementById('replyForm');
                        const textarea = document.getElementById('response');
                        const responseArea = textarea.parentElement;

                        // Global attachment storage
                        window.currentAttachments = [];

                        // Enhanced drag & drop functionality
                        function setupEnhancedDragAndDrop() {
                            // Make the entire dropzone a drag target
                            dropzone.addEventListener('dragover', function (e) {
                                e.preventDefault();
                                dropzone.classList.add('border-blue-400', 'bg-blue-50');
                                dropzone.style.transform = 'scale(1.01)';
                            });

                            dropzone.addEventListener('dragleave', function (e) {
                                e.preventDefault();
                                dropzone.classList.remove('border-blue-400', 'bg-blue-50');
                                dropzone.style.transform = 'scale(1)';
                            });

                            dropzone.addEventListener('drop', function (e) {
                                e.preventDefault();
                                dropzone.classList.remove('border-blue-400', 'bg-blue-50');
                                dropzone.style.transform = 'scale(1)';

                                console.log('Drop detected in enhanced dropzone');

                                // Handle file drops
                                if (e.dataTransfer.files.length > 0) {
                                    console.log('Files dropped:', e.dataTransfer.files.length);
                                    handleFileDrop(e.dataTransfer.files);
                                }

                                // Handle common document drops
                                if (e.dataTransfer.getData('text')) {
                                    try {
                                        const docData = JSON.parse(e.dataTransfer.getData('text'));
                                        console.log('ðŸ” RAW DROP DATA PARSED:', docData);
                                        if (docData && docData.type === 'common-document') {
                                            console.log('ðŸ“„ Common document dropped in dropzone:', docData);
                                            console.log('ðŸ“„ Document ID fields:', {
                                                _id: docData._id,
                                                id: docData.id,
                                                index: docData.index
                                            });
                                            handleCommonDocumentDrop(docData);
                                        }
                                    } catch (err) {
                                        console.error('Error parsing dropped document data:', err);
                                    }
                                }
                            });
                        }

                        // Handle file drops
                        function handleFileDrop(files) {
                            Array.from(files).forEach(file => {
                                if (isValidFile(file)) {
                                    const attachment = {
                                        id: generateAttachmentId(),
                                        type: 'file',
                                        file: file,
                                        name: file.name,
                                        size: file.size,
                                        fileType: file.type || getFileTypeFromName(file.name)
                                    };
                                    addAttachmentToPreview(attachment);
                                }
                            });
                        }

                        // Handle common document drops
                        async function handleCommonDocumentDrop(docData) {
                            console.log('ðŸ“„ Common document drop data received:', docData);
                            console.log('ðŸ“„ Document data structure:', {
                                _id: docData._id,
                                id: docData.id,
                                index: docData.index,
                                name: docData.name,
                                type: docData.type
                            });

                            try {
                                // ðŸš€ FETCH ACTUAL FILE DATA FROM DATABASE
                                const documentId = docData._id || docData.id || docData.index;
                                console.log('ðŸ”„ Fetching file data for common document:', docData.name, '(ID:', documentId + ')');

                                if (!documentId) {
                                    throw new Error('Document ID not found in document data');
                                }

                                const response = await fetch(`/api/common-documents/${documentId}/download`, { credentials: 'include' });

                                if (!response.ok) {
                                    throw new Error(`Failed to fetch document: ${response.status} ${response.statusText}`);
                                }

                                // Get the file as a blob to get actual size and content
                                const fileBlob = await response.blob();
                                console.log('âœ… Successfully fetched file blob:', fileBlob);

                                // Create a File object from the blob
                                const fileName = docData.name || 'document';
                                const fileExtension = getFileExtensionFromMimeType(fileBlob.type) || getFileExtensionFromName(fileName);
                                const actualFileName = fileName.includes('.') ? fileName : `${fileName}.${fileExtension}`;

                                const file = new File([fileBlob], actualFileName, { type: fileBlob.type });
                                console.log('âœ… Successfully converted common document to file:', file.name, 'Size:', file.size, 'Type:', file.type);

                                const attachment = {
                                    id: generateAttachmentId(),
                                    type: 'common_document',
                                    documentId: documentId,
                                    name: docData.name,
                                    size: file.size, // ðŸŽ¯ ACTUAL FILE SIZE
                                    fileType: file.type, // ðŸŽ¯ ACTUAL MIME TYPE
                                    file: file, // ðŸŽ¯ ACTUAL FILE OBJECT
                                    originalDocData: docData // Keep reference to original data
                                };

                                console.log('ðŸ“„ Created enhanced attachment object:', attachment);
                                addAttachmentToPreview(attachment);

                            } catch (error) {
                                console.error('âŒ Error fetching common document file data:', error);

                                // Fallback: create attachment without file data
                                const attachment = {
                                    id: generateAttachmentId(),
                                    type: 'common_document',
                                    documentId: docData._id || docData.id || docData.index,
                                    name: docData.name,
                                    size: 0,
                                    fileType: docData.fileType || 'application/octet-stream',
                                    error: 'Failed to fetch file data'
                                };

                                console.log('ðŸ“„ Created fallback attachment object:', attachment);
                                addAttachmentToPreview(attachment);
                            }
                        }

                        // Add attachment to preview
                        function addAttachmentToPreview(attachment) {
                            console.log('ðŸ“Ž Adding attachment to preview:', attachment);
                            window.currentAttachments.push(attachment);
                            console.log('ðŸ“Ž Current attachments array:', window.currentAttachments);
                            renderAttachmentPreview();
                            showEnhancedAttachmentPreview();
                        }

                        // Remove attachment from preview
                        function removeAttachment(attachmentId) {
                            window.currentAttachments = window.currentAttachments.filter(att => att.id !== attachmentId);
                            renderAttachmentPreview();
                            if (window.currentAttachments.length === 0) {
                                hideEnhancedAttachmentPreview();
                            }
                        }

                        // Render attachment preview
                        function renderAttachmentPreview() {
                            attachmentPreviewList.innerHTML = '';

                            window.currentAttachments.forEach(attachment => {
                                const attachmentCard = createAttachmentCard(attachment);
                                attachmentPreviewList.appendChild(attachmentCard);
                            });
                        }

                        // Create Modern Attachment Card
                        function createAttachmentCard(attachment) {
                            const card = document.createElement('div');
                            card.className = 'attachment-card-modern';
                            card.dataset.attachmentId = attachment.id;

                            // Get professional icon and color based on file type
                            const iconData = getModernFileIcon(attachment.fileType, attachment.name);
                            const size = formatFileSize(attachment.size);

                            // Status info with different badges
                            let statusBadge = '';
                            if (attachment.type === 'common_document') {
                                if (attachment.file && attachment.file.size > 0) {
                                    statusBadge = `<span class="status-badge success"><i class="fas fa-check-circle"></i> Ready</span>`;
                                } else if (attachment.error) {
                                    statusBadge = `<span class="status-badge error"><i class="fas fa-exclamation-circle"></i> Error</span>`;
                                } else {
                                    statusBadge = `<span class="status-badge loading"><i class="fas fa-spinner fa-spin"></i> Loading...</span>`;
                                }
                            } else {
                                statusBadge = `<span class="status-badge">${size}</span>`;
                            }

                            card.innerHTML = `
                        <div class="attachment-icon" style="background: ${iconData.background}; color: ${iconData.color};">
                            <i class="${iconData.icon}"></i>
                        </div>
                        <div class="attachment-info">
                            <div class="attachment-name" title="${attachment.name}">${attachment.name}</div>
                            <div class="attachment-meta">
                                ${statusBadge}
                                ${attachment.type === 'common_document' && attachment.file && attachment.file.size > 0 ? `<span class="file-size">${size}</span>` : ''}
                                ${attachment.fileType ? `<span class="file-type">${getFileTypeLabel(attachment.fileType)}</span>` : ''}
                            </div>
                        </div>
                        <button type="button" class="attachment-remove" onclick="removeAttachment('${attachment.id}')" title="Remove attachment">
                            <i class="fas fa-times"></i>
                        </button>
                    `;

                            return card;
                        }

                        // Modern File Icon System
                        function getModernFileIcon(fileType, fileName = '') {
                            const ext = fileName.split('.').pop().toLowerCase();

                            // PDF
                            if (fileType.includes('pdf') || ext === 'pdf') {
                                return {
                                    icon: 'fas fa-file-pdf',
                                    color: '#ef4444',
                                    background: 'rgba(239, 68, 68, 0.12)'
                                };
                            }

                            // Word Documents
                            if (fileType.includes('word') || fileType.includes('document') || ['doc', 'docx'].includes(ext)) {
                                return {
                                    icon: 'fas fa-file-word',
                                    color: '#3b82f6',
                                    background: 'rgba(59, 130, 246, 0.12)'
                                };
                            }

                            // Excel/Spreadsheets
                            if (fileType.includes('excel') || fileType.includes('spreadsheet') || ['xls', 'xlsx', 'csv'].includes(ext)) {
                                return {
                                    icon: 'fas fa-file-excel',
                                    color: '#10b981',
                                    background: 'rgba(16, 185, 129, 0.12)'
                                };
                            }

                            // Images
                            if (fileType.includes('image') || ['jpg', 'jpeg', 'png', 'gif', 'svg', 'webp'].includes(ext)) {
                                return {
                                    icon: 'fas fa-file-image',
                                    color: '#a855f7',
                                    background: 'rgba(168, 85, 247, 0.12)'
                                };
                            }

                            // Text Files
                            if (fileType.includes('text') || ext === 'txt') {
                                return {
                                    icon: 'fas fa-file-alt',
                                    color: '#64748b',
                                    background: 'rgba(100, 116, 139, 0.12)'
                                };
                            }

                            // Archives/Zip
                            if (fileType.includes('zip') || fileType.includes('archive') || ['zip', 'rar', '7z', 'tar', 'gz'].includes(ext)) {
                                return {
                                    icon: 'fas fa-file-archive',
                                    color: '#f59e0b',
                                    background: 'rgba(245, 158, 11, 0.12)'
                                };
                            }

                            // Default
                            return {
                                icon: 'fas fa-file',
                                color: '#6b7280',
                                background: 'rgba(107, 114, 128, 0.12)'
                            };
                        }

                        // Get friendly file type label
                        function getFileTypeLabel(fileType) {
                            if (fileType.includes('pdf')) return 'PDF';
                            if (fileType.includes('word') || fileType.includes('document')) return 'Document';
                            if (fileType.includes('excel') || fileType.includes('spreadsheet')) return 'Spreadsheet';
                            if (fileType.includes('image')) return 'Image';
                            if (fileType.includes('text')) return 'Text';
                            if (fileType.includes('zip') || fileType.includes('archive')) return 'Archive';

                            // Extract from MIME type
                            const parts = fileType.split('/');
                            if (parts.length > 1) {
                                return parts[1].split('.').pop().toUpperCase();
                            }
                            return 'File';
                        }

                        // Helper functions
                        function generateAttachmentId() {
                            return 'att_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                        }

                        function isValidFile(file) {
                            const maxSize = 10 * 1024 * 1024; // 10MB
                            const allowedTypes = ['.pdf', '.doc', '.docx', '.jpg', '.jpeg', '.png', '.xlsx', '.xls', '.txt', '.csv', '.zip'];

                            if (file.size > maxSize) {
                                showNotification(`File ${file.name} is too large (max 10MB)`, 'error');
                                return false;
                            }

                            const extension = '.' + file.name.split('.').pop().toLowerCase();
                            if (!allowedTypes.includes(extension)) {
                                showNotification(`File type ${extension} not allowed`, 'error');
                                return false;
                            }

                            return true;
                        }

                        function getFileTypeFromName(filename) {
                            const ext = filename.split('.').pop().toLowerCase();
                            const typeMap = {
                                'pdf': 'application/pdf',
                                'doc': 'application/msword',
                                'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                                'jpg': 'image/jpeg',
                                'jpeg': 'image/jpeg',
                                'png': 'image/png',
                                'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                                'xls': 'application/vnd.ms-excel',
                                'txt': 'text/plain',
                                'csv': 'text/csv',
                                'zip': 'application/zip'
                            };
                            return typeMap[ext] || 'application/octet-stream';
                        }

                        function getFileTypeIcon(fileType) {
                            if (fileType.includes('pdf')) return 'ðŸ“„';
                            if (fileType.includes('word') || fileType.includes('document')) return 'ðŸ“';
                            if (fileType.includes('excel') || fileType.includes('spreadsheet')) return 'ðŸ“Š';
                            if (fileType.includes('image')) return 'ðŸ–¼ï¸';
                            if (fileType.includes('text')) return 'ðŸ“„';
                            if (fileType.includes('zip')) return 'ðŸ“¦';
                            return 'ðŸ“Ž';
                        }

                        function formatFileSize(bytes) {
                            if (bytes === 0) return '0 Bytes';
                            const k = 1024;
                            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                            const i = Math.floor(Math.log(bytes) / Math.log(k));
                            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
                        }

                        // ðŸš€ NEW: Helper functions for file extensions
                        function getFileExtensionFromMimeType(mimeType) {
                            const mimeToExt = {
                                'application/pdf': 'pdf',
                                'application/msword': 'doc',
                                'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'docx',
                                'image/jpeg': 'jpg',
                                'image/png': 'png',
                                'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': 'xlsx',
                                'application/vnd.ms-excel': 'xls',
                                'text/plain': 'txt',
                                'text/csv': 'csv',
                                'application/zip': 'zip'
                            };
                            return mimeToExt[mimeType] || null;
                        }

                        function getFileExtensionFromName(filename) {
                            const parts = filename.split('.');
                            return parts.length > 1 ? parts[parts.length - 1].toLowerCase() : null;
                        }

                        function showEnhancedAttachmentPreview() {
                            enhancedAttachmentPreview.classList.remove('hidden');
                        }

                        function hideEnhancedAttachmentPreview() {
                            enhancedAttachmentPreview.classList.add('hidden');
                        }

                        // Reply form submission: handled by SINGLE handler above (clone/replace block).
                        // Do NOT add another submit handler here - it caused duplicate POSTs and duplicate DB replies.

                        // Setup clear all button
                        const clearAllBtn = document.getElementById('clearAllAttachments');
                        if (clearAllBtn) {
                            clearAllBtn.addEventListener('click', function () {
                                console.log('ðŸ—‘ï¸ Clearing all attachments');
                                window.currentAttachments = [];
                                renderAttachmentPreview();
                                hideEnhancedAttachmentPreview();
                                showNotification('All attachments cleared', 'info');
                            });
                            console.log('âœ… CLEAR ALL ATTACHMENTS BUTTON SETUP COMPLETE');
                        }

                        // Initialize enhanced drag & drop
                        setupEnhancedDragAndDrop();
                        console.log('âœ… ENHANCED ATTACHMENT SYSTEM FULLY INITIALIZED');

                        // Make removeAttachment globally accessible
                        window.removeAttachment = removeAttachment;

                        // ENHANCED: Make common documents in sidebar draggable
                        function makeCommonDocumentsDraggable() {
                            const documentsContainer = document.getElementById('documentsContainer');
                            if (documentsContainer) {
                                // Add drag event listeners to all document items
                                documentsContainer.addEventListener('mousedown', function (e) {
                                    const documentItem = e.target.closest('[data-document-id]');
                                    if (documentItem) {
                                        documentItem.draggable = true;
                                        documentItem.addEventListener('dragstart', function (e) {
                                            const documentId = this.dataset.documentId;
                                            const documentName = this.querySelector('.document-name')?.textContent || 'Document';
                                            const documentSize = this.dataset.documentSize || 0;
                                            const documentType = this.dataset.documentType || 'application/octet-stream';

                                            const dragData = {
                                                type: 'common-document',
                                                index: documentId,
                                                name: documentName,
                                                size: parseInt(documentSize),
                                                fileType: documentType
                                            };

                                            e.dataTransfer.setData('text', JSON.stringify(dragData));
                                            e.dataTransfer.effectAllowed = 'copy';

                                            console.log(`ðŸ“„ Started dragging common document: ${documentName} (ID: ${documentId})`);
                                        });
                                    }
                                });
                            }
                        }

                        // Initialize draggable common documents
                        makeCommonDocumentsDraggable();

                        // ðŸš€ ENHANCED: Handle standard file input change using new system
                        fileInput.addEventListener('change', function (e) {
                            console.log('ðŸ“Ž File input change detected', this.files.length, 'files');

                            if (this.files.length === 0) return; // No files selected

                            // Process the new files using the enhanced attachment system
                            Array.from(this.files).forEach(file => {
                                if (isValidFile(file)) {
                                    const attachment = {
                                        id: generateAttachmentId(),
                                        type: 'file',
                                        file: file,
                                        name: file.name,
                                        size: file.size,
                                        fileType: file.type || getFileTypeFromName(file.name)
                                    };
                                    addAttachmentToPreview(attachment);
                                }
                            });

                            // Clear the input to allow selecting the same files again
                            this.value = '';
                        });

                        // Handle click on attachment button - SINGLE SOURCE OF TRUTH
                        const attachmentBtn = document.getElementById('attachmentBtn');
                        if (attachmentBtn) {
                            attachmentBtn.addEventListener('click', function (e) {
                                e.preventDefault(); // Prevent any default action
                                e.stopPropagation(); // Stop event from bubbling
                                console.log('Attachment button clicked');

                                // Trigger file input click
                                fileInput.click();
                            });
                        }
                        // Global flag to prevent duplicate document processing across drop zones

                        // Make the entire text area a drop zone
                        textarea.addEventListener('dragover', function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            textarea.classList.add('bg-gray-50');
                        });

                        textarea.addEventListener('dragleave', function (e) {
                            e.preventDefault();
                            textarea.classList.remove('bg-gray-50');
                        });

                        textarea.addEventListener('drop', function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            textarea.classList.remove('bg-gray-50');

                            if (e.dataTransfer.files.length > 0) {
                                console.log('ðŸ“Ž Files dropped in textarea - using enhanced system');
                                // Process files using enhanced attachment system
                                Array.from(e.dataTransfer.files).forEach(file => {
                                    if (isValidFile(file)) {
                                        const attachment = {
                                            id: generateAttachmentId(),
                                            type: 'file',
                                            file: file,
                                            name: file.name,
                                            size: file.size,
                                            fileType: file.type || getFileTypeFromName(file.name)
                                        };
                                        addAttachmentToPreview(attachment);
                                    }
                                });
                            } else if (e.dataTransfer.getData('text')) {
                                // This might be a document dragged from the Common Documents section
                                try {
                                    const docData = JSON.parse(e.dataTransfer.getData('text'));
                                    console.log('Received dragged data:', docData);

                                    if (docData && docData.type === 'common-document') {
                                        // Validate document data
                                        const documentId = docData._id || docData.id || docData.index;

                                        if (!documentId) {
                                            console.error('âŒ Invalid document data - index is undefined:', docData);
                                            showNotification('Error: Invalid document data', 'error');
                                            return;
                                        }

                                        // Prevent duplicate processing using global flag and timestamp
                                        const currentTime = Date.now();
                                        const docKey = `${documentId}_${docData.name}`;

                                        console.log('Document drop detected:', {
                                            docKey,
                                            _id: documentId,
                                            name: docData.name,
                                            alreadyProcessed: processedDocuments.has(docKey),
                                            lastProcessed: lastProcessedDocument,
                                            timeSinceLast: currentTime - lastProcessedTime
                                        });

                                        if (!processedDocuments.has(docKey)) {
                                            processedDocuments.add(docKey);
                                            lastProcessedDocument = docKey;
                                            lastProcessedTime = currentTime;
                                            console.log('âœ… Processing document drop in textarea:', docKey);
                                            // ðŸš€ FIXED: Call the proper handler to add document to chat
                                            handleCommonDocumentDrop(docData);
                                        } else {
                                            console.log('âŒ Duplicate document drop prevented:', docKey);
                                            showNotification('Document already added to chat', 'info');
                                        }
                                    }
                                } catch (err) {
                                    console.error('Error parsing dragged data:', err);
                                }
                            }
                        });



                        // Note: makeDocumentsDraggable function removed - drag and drop is now handled directly in loadDocuments



                        // ðŸš€ REMOVED: Old helper functions - replaced by enhanced system

                        // Create preview for uploaded files
                        // ðŸš€ REMOVED: Old createAttachmentPreview function - replaced by enhanced system

                        // ðŸš€ REMOVED: Old updateAttachmentCounter and formatFileSize functions - replaced by enhanced system

                        // DUPLICATE EVENT LISTENER REMOVED - Form submission is now handled by the single unified event listener above
                        // This prevents triple submissions and ensures webhook is triggered only once

                        // Add handler for the "Show Attachments" button in dropdown
                        const showAttachmentsBtn = document.getElementById('showAttachmentsBtn');
                        if (showAttachmentsBtn) {
                            showAttachmentsBtn.addEventListener('click', function (e) {
                                e.preventDefault();
                                e.stopPropagation();
                                console.log('Show attachments button clicked');
                                // Just trigger the attachmentBtn click which will trigger file input
                                if (attachmentBtn) {
                                    attachmentBtn.click();
                                }
                                document.getElementById('quickResponseDropdown').style.display = 'none';
                            });
                        }
                    }



                    // Setup quick response dropdown
                    function setupQuickResponseDropdown() {
                        const quickResponseBtn = document.getElementById('quickResponseBtn');
                        const quickResponseDropdown = document.getElementById('quickResponseDropdown');
                        const responseTextarea = document.getElementById('response');
                        const attachmentBtn = document.getElementById('attachmentBtn');

                        if (!quickResponseBtn || !quickResponseDropdown || !responseTextarea) return;

                        // Initially hide the dropdown
                        quickResponseDropdown.style.display = 'none';

                        // Toggle dropdown visibility when clicking the button
                        quickResponseBtn.addEventListener('click', function (e) {
                            e.preventDefault();
                            e.stopPropagation();

                            if (quickResponseBtn.classList.contains('open')) {
                                quickResponseBtn.classList.remove('open');
                                quickResponseDropdown.style.display = 'none';
                            } else {
                                quickResponseBtn.classList.add('open');
                                quickResponseDropdown.style.display = 'block';
                            }
                        });

                        // Close dropdown when clicking outside
                        document.addEventListener('click', function (e) {
                            if (quickResponseBtn && !quickResponseBtn.contains(e.target) &&
                                quickResponseDropdown && quickResponseDropdown.style.display !== 'none') {
                                quickResponseBtn.classList.remove('open');
                                quickResponseDropdown.style.display = 'none';
                            }
                        });

                        // Add click handlers for quick response items
                        document.querySelectorAll('.quick-response-item').forEach(item => {
                            item.addEventListener('click', function (e) {
                                const text = this.textContent.trim();

                                // Insert different template responses based on the selected option
                                let responseTemplate = '';

                                if (text.includes('Issue Resolved')) {
                                    responseTemplate = "I'm pleased to inform you that we have resolved the issue with your claim. The necessary repairs have been authorized and you can proceed with scheduling service at your convenience.\n\nPlease let me know if you need any additional assistance.";
                                } else if (text.includes('Need More Information')) {
                                    responseTemplate = "Thank you for your claim submission. To proceed with your case, we need some additional information:\n\n1. Complete diagnostic report with fault codes\n2. Photos of the affected components\n3. Service history records\n\nPlease provide these at your earliest convenience so we can continue processing your claim.";
                                } else if (text.includes('In Progress Update')) {
                                    responseTemplate = "I wanted to provide you with an update on your claim. We are currently reviewing your case and have forwarded the documentation to our technical specialist.\n\nWe expect to have a decision within 2-3 business days. Thank you for your patience.";
                                } else if (text.includes('Schedule Follow-up')) {
                                    responseTemplate = "I've reviewed your claim and would like to schedule a follow-up call to discuss the next steps. Please let me know your availability in the next few days, and I'll arrange for our technical advisor to contact you directly.";
                                } else if (text.includes('Attach Files')) {
                                    // Trigger attachment button click - this will open the file dialog
                                    if (attachmentBtn) {
                                        attachmentBtn.click();
                                    }
                                    quickResponseDropdown.style.display = 'none';
                                    return;
                                } else if (text.includes('Save as Template')) {
                                    // Open the template modal with current response text
                                    document.getElementById('templateTitle').value = 'New Response Template';
                                    document.getElementById('templateContent').value = responseTextarea.value;
                                    document.getElementById('editTemplateTitle').textContent = 'Save as Template';
                                    document.getElementById('deleteTemplate').classList.add('hidden');
                                    document.getElementById('saveTemplate').removeAttribute('data-template-index');
                                    openModal('editTemplateModal');
                                    quickResponseDropdown.style.display = 'none';
                                    return;
                                }

                                // Insert the template text into the textarea
                                if (responseTemplate) {
                                    // If there's already content, add a line break first
                                    if (responseTextarea.value && !responseTextarea.value.endsWith('\n')) {
                                        responseTextarea.value += '\n\n';
                                    }

                                    responseTextarea.value += responseTemplate;
                                    responseTextarea.focus();

                                    // Move cursor to end of text
                                    responseTextarea.selectionStart = responseTextarea.selectionEnd = responseTextarea.value.length;

                                    // Trigger auto-expand after adding template content
                                    if (typeof window.autoExpandTextarea === 'function') {
                                        window.autoExpandTextarea(responseTextarea);
                                    }

                                    // Hide the dropdown
                                    quickResponseBtn.classList.remove('open');
                                    quickResponseDropdown.style.display = 'none';
                                }
                            });
                        });
                    }

                    // Function to view common documents from reply attachments
                    function viewCommonDocument(documentId) {
                        try {
                            // Download the common document
                            const downloadUrl = `/api/common-documents/${documentId}/download`;

                            // Open in new window/tab
                            const newWindow = window.open(downloadUrl, '_blank');
                            if (!newWindow) {
                                showNotification('Download failed - popup blocked?', 'error');
                            }

                        } catch (error) {
                            showNotification(`Error viewing document: ${error.message}`, 'error');
                        }
                    }

                    // Initialize everything when DOM is loaded
                    document.addEventListener('DOMContentLoaded', function () {
                        // Initialize global variables
                        processedDocuments.clear();
                        lastProcessedDocument = null;
                        lastProcessedTime = 0;

                        // Load existing documents
                        loadDocuments();

                        // Setup event handlers for attachments
                        setupAttachmentHandlers();

                        // Setup quick response dropdown
                        setupQuickResponseDropdown();



                        // Add a function to manually clear processed documents (for debugging)
                        window.clearProcessedDocuments = function () {
                            processedDocuments.clear();
                            lastProcessedDocument = null;
                            lastProcessedTime = 0;
                            console.log('ðŸ§¹ Manually cleared processed documents tracking');
                            showNotification('Processed documents tracking cleared', 'success');
                        };
                    });

                    // Note: Removed problematic setInterval that was causing duplicate event listeners
                    // Documents are now made draggable only when they are initially loaded

                    // Auto-refresh functionality for webhook replies
                    let lastReplyCount = parseInt('{{ replies|length|default(0) }}', 10);
                    let autoRefreshInterval;

                    const ticketCustomerName = '{{ (ticket.name or ticket.customer_first_name or "")|default("", true) }}';

                    function escapeHtml(text) {
                        if (!text) return '';
                        return text.replace(/[&<>"']/g, function (c) {
                            return {
                                '&': '&amp;',
                                '<': '&lt;',
                                '>': '&gt;',
                                '"': '&quot;',
                                "'": '&#39;'
                            }[c] || c;
                        });
                    }

                    function renderRepliesFromApi(replies) {
                        const container = document.getElementById('repliesContainer');
                        if (!container) return;

                        container.innerHTML = '';

                        (replies || []).forEach((reply, idx) => {
                            const isInternal = (
                                (reply.role && ['Admin', 'Support', 'Technical Director', 'Technician'].includes(reply.role)) ||
                                reply.sender_type === 'agent' ||
                                reply.is_internal
                            );

                            const wrapper = document.createElement('div');
                            wrapper.className = 'message ' + (isInternal ? 'support-message' : 'customer-message');

                            const messageId = 'message-' + (idx + 1);
                            const senderName = isInternal
                                ? (reply.sender_name || 'Support Team')
                                : (reply.sender_name || ticketCustomerName || 'Customer');

                            const createdAt = reply.created_at
                                ? new Date(reply.created_at).toLocaleString()
                                : '';

                            // Build attachment HTML
                            let attachmentHtml = '';
                            const atts = reply.attachments || [];
                            if (atts.length > 0) {
                                const replyId = reply._id || '';
                                const attItems = atts.map((att, attIdx) => {
                                    const filename = att.filename || att.fileName || att.name || 'file';
                                    const ext = filename.toLowerCase().split('.').pop();
                                    const previewExts = ['jpg', 'jpeg', 'png', 'gif', 'pdf', 'txt', 'md', 'webp', 'svg', 'bmp'];
                                    const canPreview = previewExts.includes(ext);
                                    // Determine icon
                                    let iconClass = 'fas fa-file text-gray-500';
                                    if (['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'svg'].includes(ext)) iconClass = 'fas fa-image text-blue-400';
                                    else if (ext === 'pdf') iconClass = 'fas fa-file-pdf text-red-400';
                                    else if (['doc', 'docx'].includes(ext)) iconClass = 'fas fa-file-word text-blue-400';

                                    return `
                                    <div class="flex items-center bg-white/5 border border-white/10 rounded-lg p-2 gap-2">
                                        <i class="${iconClass} mr-1 flex-shrink-0"></i>
                                        <div class="min-w-0 flex-1">
                                            <div class="font-medium truncate max-w-[120px]" title="${escapeHtml(filename)}">${escapeHtml(filename)}</div>
                                        </div>
                                        <div class="flex gap-1 ml-2 flex-shrink-0">
                                            ${canPreview ? `<button onclick="previewAttachment('${escapeHtml(replyId)}', '${attIdx}', '${escapeHtml(filename)}', 'reply')"
                                                class="bg-blue-100 hover:bg-blue-200 text-blue-600 px-1.5 py-1 rounded text-[10px] transition"
                                                title="Preview ${escapeHtml(filename)}"><i class="fas fa-eye"></i></button>` : ''}
                                            <button onclick="downloadAttachment('${escapeHtml(replyId)}', '${attIdx}', '${escapeHtml(filename)}', 'reply')"
                                                class="bg-green-100 hover:bg-green-200 text-green-600 px-1.5 py-1 rounded text-[10px] transition"
                                                title="Download ${escapeHtml(filename)}"><i class="fas fa-download"></i></button>
                                        </div>
                                    </div>`;
                                }).join('');
                                attachmentHtml = `<div class="flex flex-wrap gap-2 mt-3">${attItems}</div>`;
                            }

                            const contentId = `message-content-${idx + 1}`;
                            const btnId = `toggle-btn-${idx + 1}`;

                            wrapper.innerHTML = `
                                <div class="message-header">
                                    <span class="font-medium flex items-center">
                                        ${isInternal
                                    ? '<i class="fas fa-headset support-icon"></i> ' + escapeHtml(senderName)
                                    : '<i class="fas fa-user-circle customer-icon"></i> ' + escapeHtml(senderName)
                                }
                                    </span>
                                    <span class="message-time">
                                        <i class="fas fa-clock mr-1"></i>${escapeHtml(createdAt)}
                                    </span>
                                </div>
                                <div class="reply-message-box" id="${messageId}">
                                    <div class="message-content line-clamp-3 overflow-hidden text-gray-200 transition-all duration-300"
                                         id="${contentId}"
                                         style="display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; line-height: 1.6;">
                                        ${escapeHtml(reply.message || '')}
                                    </div>
                                    <button onclick="toggleMessage('${idx + 1}')" id="${btnId}"
                                        class="text-blue-400 hover:text-blue-300 text-xs mt-2 font-medium flex items-center focus:outline-none hidden">
                                        <i class="fas fa-chevron-down mr-1"></i> Read More
                                    </button>
                                    ${attachmentHtml}
                                </div>
                            `;

                            container.appendChild(wrapper);
                        });

                        // After rendering all replies, detect truncation and show toggle buttons
                        setTimeout(() => {
                            (replies || []).forEach((reply, idx) => {
                                const content = document.getElementById(`message-content-${idx + 1}`);
                                const btn = document.getElementById(`toggle-btn-${idx + 1}`);
                                if (content && btn) {
                                    const clampedHeight = content.clientHeight;
                                    content.style.webkitLineClamp = 'unset';
                                    content.style.display = 'block';
                                    const fullHeight = content.scrollHeight;
                                    content.style.webkitLineClamp = '3';
                                    content.style.display = '-webkit-box';
                                    if (fullHeight > clampedHeight + 5) {
                                        btn.classList.remove('hidden');
                                    }
                                }
                            });
                        }, 150);
                    }

                    function checkForNewReplies() {
                        fetch(`/api/tickets/{{ ticket.ticket_id }}/reply-count`)
                            .then(response => response.json())
                            .then(data => {
                                if (data.success && typeof data.count === 'number' && data.count > lastReplyCount) {
                                    console.log(`ðŸ”„ New replies detected! (${lastReplyCount} â†’ ${data.count})`);
                                    lastReplyCount = data.count;
                                    fetch(`/api/tickets/{{ ticket.ticket_id }}/replies`)
                                        .then(r => r.json())
                                        .then(replyData => {
                                            if (replyData.success) {
                                                renderRepliesFromApi(replyData.replies || []);
                                            }
                                        })
                                        .catch(error => console.error('Error loading replies:', error));
                                }
                            })
                            .catch(error => console.error('Error checking for new replies:', error));
                    }

                    // Auto-refresh: always-on, every 5 seconds
                    setInterval(checkForNewReplies, 5000);

                    // Clear processed documents on page unload
                    window.addEventListener('beforeunload', function () {
                        processedDocuments.clear();
                        lastProcessedDocument = null;
                        lastProcessedTime = 0;
                    });

                    document.addEventListener('DOMContentLoaded', function () {
                        console.log('ðŸš€ Ticket Detail page loaded');

                        // Check for AI response on page load
                        checkForAIResponse();

                        // AI Response checking function
                        function checkForAIResponse() {
                            console.log('ðŸ¤– Checking for AI response...');
                            const ticketId = '{{ ticket.ticket_id }}';

                            // Check URL parameters first
                            const urlParams = new URLSearchParams(window.location.search);
                            const aiResponse = urlParams.get('ai_response');

                            if (aiResponse) {
                                console.log('ðŸ“ Found AI response in URL parameters');
                                populateTextareaWithAIResponse(decodeURIComponent(aiResponse));
                                return;
                            }

                            // Check for AI response in database
                            fetch(`/api/ai/get-response/${ticketId}`)
                                .then(response => response.json())
                                .then(data => {
                                    if (data.success && data.ai_response) {
                                        console.log('ðŸ“ Found AI response in database');
                                        populateTextareaWithAIResponse(data.ai_response);
                                    } else {
                                        console.log('â„¹ï¸ No AI response found');
                                    }
                                })
                                .catch(error => {
                                    console.log('âš ï¸ Error checking for AI response:', error);
                                });
                        }

                        // Function to populate textarea with AI response
                        function populateTextareaWithAIResponse(aiResponse) {
                            console.log('ðŸ”§ Populating textarea with AI response...');
                            const textarea = document.getElementById('response');

                            if (textarea) {
                                console.log('âœ… Found textarea, setting value...');
                                textarea.value = aiResponse;
                                console.log('ðŸ“ Textarea populated with:', aiResponse.substring(0, 100) + '...');

                                // Trigger auto-expand
                                if (window.autoExpandTextarea) {
                                    window.autoExpandTextarea(textarea);
                                }

                                // Trigger input event to save to localStorage
                                textarea.dispatchEvent(new Event('input', { bubbles: true }));

                                // Show notification
                                showNotification('AI response loaded into textarea!', 'success');

                                console.log('ðŸŽ‰ AI response successfully loaded!');
                            } else {
                                console.error('âŒ Textarea not found!');
                            }
                        }

                        // Auto-expand textarea functionality (WhatsApp-style) - GLOBAL SCOPE
                        window.autoExpandTextarea = function (textareaElement) {
                            if (!textareaElement) return;

                            // Temporarily disable transition for measurement
                            const originalTransition = textareaElement.style.transition;
                            textareaElement.style.transition = 'none';

                            // Reset height to auto to get accurate scrollHeight
                            textareaElement.style.height = 'auto';

                            // Get the scroll height (full content height)
                            const scrollHeight = textareaElement.scrollHeight;

                            // Re-enable transition for smooth height change
                            textareaElement.style.transition = originalTransition;

                            // Set the height based on content, respecting min/max limits
                            const minHeight = 60; // minimum height (about 3 lines)
                            const maxHeight = 300; // maximum height (about 15 lines)

                            if (scrollHeight <= maxHeight) {
                                textareaElement.style.height = Math.max(scrollHeight, minHeight) + 'px';
                                textareaElement.style.overflowY = 'hidden';
                            } else {
                                textareaElement.style.height = maxHeight + 'px';
                                textareaElement.style.overflowY = 'auto';
                            }
                        };

                        // Initialize auto-expand for response textarea
                        const responseTextarea = document.getElementById('response');
                        if (responseTextarea) {
                            console.log('âœ… Found response textarea, initializing auto-expand');

                            // Apply auto-expand on input events (main trigger)
                            responseTextarea.addEventListener('input', function () {
                                window.autoExpandTextarea(this);
                            });

                            // Apply auto-expand on page load (for existing content)
                            if (responseTextarea.value && responseTextarea.value.trim()) {
                                setTimeout(() => window.autoExpandTextarea(responseTextarea), 100);
                            }

                            // Apply auto-expand on paste operations
                            responseTextarea.addEventListener('paste', function () {
                                setTimeout(() => window.autoExpandTextarea(this), 50);
                            });

                            // Apply auto-expand on any value changes
                            responseTextarea.addEventListener('change', function () {
                                window.autoExpandTextarea(this);
                            });

                            // Apply auto-expand on focus (in case content was added programmatically)
                            responseTextarea.addEventListener('focus', function () {
                                setTimeout(() => window.autoExpandTextarea(this), 10);
                            });

                            console.log('âœ… Auto-expand textarea initialized successfully');
                        } else {
                            console.error('âŒ Response textarea not found');
                        }

                        // Forward ticket functionality
                        const forwardModal = document.getElementById('forwardModal');
                        const forwardBtn = document.getElementById('forwardBtn');
                        const closeForwardModalBtn = document.getElementById('closeForwardModal');
                        const cancelForwardBtn = document.getElementById('cancelForward');
                        const confirmForwardBtn = document.getElementById('confirmForward');

                        if (forwardBtn) {
                            forwardBtn.addEventListener('click', () => {
                                console.log('ðŸ“¤ Forward button clicked');

                                // Reset form when opening
                                const memberSelectEl = document.getElementById('forwardMemberSelect');
                                const notesEl = document.getElementById('forwardNotes');
                                if (memberSelectEl) memberSelectEl.value = '';
                                if (notesEl) notesEl.value = '';

                                // Open modal using the helper function
                                openModal('forwardModal');
                            });
                        }

                        if (closeForwardModalBtn) {
                            closeForwardModalBtn.addEventListener('click', () => closeModal('forwardModal'));
                        }

                        if (cancelForwardBtn) {
                            cancelForwardBtn.addEventListener('click', () => closeModal('forwardModal'));
                        }

                        if (confirmForwardBtn) {
                            confirmForwardBtn.addEventListener('click', async () => {
                                console.log('ðŸš€ Forward confirmation clicked');

                                try {
                                    // Get form elements
                                    const memberSelectEl = document.getElementById('forwardMemberSelect');
                                    const notesEl = document.getElementById('forwardNotes');

                                    if (!memberSelectEl || !notesEl) {
                                        showNotification('Form elements not found - please refresh the page', 'error');
                                        return;
                                    }

                                    const memberId = memberSelectEl.value;
                                    const notes = notesEl.value;

                                    // SAFE TICKET ID handling
                                    const ticketId = "{{ ticket.ticket_id }}";
                                    console.log('ðŸ†” Forwarding Ticket ID:', ticketId);

                                    // Validation
                                    console.log('ðŸ‘¤ Selected Member ID:', memberId);
                                    if (!memberId || memberId.trim() === '' || memberId === 'Select a member...') {
                                        console.warn('âš ï¸ Member validation failed');
                                        showNotification('Please select a member to forward the ticket to', 'error');

                                        // VISUAL FEEDBACK
                                        memberSelectEl.classList.add('border-red-500', 'ring-2', 'ring-red-500');
                                        memberSelectEl.focus();

                                        // Remove error class after 3 seconds or on change
                                        setTimeout(() => {
                                            memberSelectEl.classList.remove('border-red-500', 'ring-2', 'ring-red-500');
                                        }, 3000);

                                        memberSelectEl.addEventListener('change', function () {
                                            memberSelectEl.classList.remove('border-red-500', 'ring-2', 'ring-red-500');
                                        }, { once: true });

                                        return;
                                    }

                                    // Validate session member_id for forwarding
                                    const sessionMemberId = "{{ session.member_id if session.member_id else '' }}";
                                    console.log('ðŸ†” Session Member ID:', sessionMemberId);

                                    if (!sessionMemberId || sessionMemberId === 'None' || sessionMemberId === 'null' || sessionMemberId === '') {
                                        console.warn('âš ï¸ Session validation failed');
                                        showNotification('Session expired. Please refresh the page and log in again.', 'error');
                                        return;
                                    }

                                    // Prepare API request
                                    const requestBody = {
                                        assigned_to: memberId.trim(),
                                        note: notes.trim(),
                                        is_forwarded: true,
                                        forwarded_from: sessionMemberId
                                    };

                                    console.log('ðŸ”„ Preparing forward request:', requestBody);

                                    // Disable button to prevent double-clicks
                                    confirmForwardBtn.disabled = true;
                                    confirmForwardBtn.innerHTML = 'â³ Forwarding...';

                                    console.log('ðŸ“¡ Sending API request to:', `/api/tickets/${ticketId}/assign`);

                                    const response = await fetch(`/api/tickets/${ticketId}/assign`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify(requestBody),
                                        credentials: 'include'
                                    });

                                    console.log('ðŸ“¥ Response received. Status:', response.status);

                                    const data = await response.json();
                                    console.log('ðŸ“¦ Response data:', data);

                                    if (response.ok && data.status === 'success') {
                                        console.log('âœ… Forward SUCCESS!');

                                        // SUCCESS STATE: Show success button state
                                        confirmForwardBtn.disabled = false;
                                        confirmForwardBtn.innerHTML = 'âœ… Forwarded Successfully!';
                                        confirmForwardBtn.style.backgroundColor = '#dcfce7';
                                        confirmForwardBtn.style.color = '#166534';

                                        // Close modal and reset form
                                        closeModal('forwardModal');
                                        memberSelectEl.value = '';
                                        notesEl.value = '';

                                        // Show brief success notification
                                        showNotification('Ticket forwarded successfully!', 'success');

                                        // Update forward button state dynamically
                                        const selectedMemberName = memberSelectEl.options[memberSelectEl.selectedIndex].text;
                                        updateForwardButtonState(selectedMemberName);

                                        // Refresh the page to show updated assignment
                                        setTimeout(() => {
                                            window.location.reload();
                                        }, 2000);
                                    } else {
                                        console.error('âŒ Forward FAILED:', data);

                                        let errorMessage = 'Failed to forward ticket';
                                        if (data.message) {
                                            errorMessage = data.message;
                                        }

                                        showNotification(errorMessage, 'error');

                                        // Reset button
                                        confirmForwardBtn.disabled = false;
                                        confirmForwardBtn.innerHTML = 'Forward Ticket';
                                    }
                                } catch (error) {
                                    console.error('âŒ Forward Exception:', error);

                                    // Reset button
                                    confirmForwardBtn.disabled = false;
                                    confirmForwardBtn.innerHTML = 'Forward Ticket';

                                    showNotification('An error occurred while forwarding ticket', 'error');
                                }
                            });
                        }

                        // Function to update forward button state after forwarding
                        function updateForwardButtonState(forwardedToName) {
                            const forwardBtn = document.getElementById('forwardBtn');
                            if (forwardBtn) {
                                forwardBtn.style.display = 'none';

                                // Create or update forward status badge
                                let forwardBadge = document.getElementById('forwardStatusBadge');
                                if (!forwardBadge) {
                                    forwardBadge = document.createElement('div');
                                    forwardBadge.id = 'forwardStatusBadge';
                                    forwardBadge.className = 'px-3 h-9 flex items-center justify-center rounded-xl bg-blue-50 text-blue-700 border border-blue-200 whitespace-nowrap flex-shrink-0';
                                    forwardBtn.parentNode.insertBefore(forwardBadge, forwardBtn);
                                }
                                forwardBadge.innerHTML = `<i class="fas fa-share mr-1"></i> Forwarded to ${forwardedToName}`;
                            }
                        }
                    });

                    // Mobile menu toggle function
                    function toggleMobileMenu() {
                        const mobileMenu = document.getElementById('mobileMenu');
                        if (mobileMenu) {
                            mobileMenu.classList.toggle('active');
                        }
                    }

                    // Close mobile menu when clicking outside
                    document.addEventListener('click', function (event) {
                        const mobileMenu = document.getElementById('mobileMenu');
                        const menuButton = document.querySelector('.mobile-menu-btn');

                        if (mobileMenu && !mobileMenu.contains(event.target) && !menuButton.contains(event.target)) {
                            mobileMenu.classList.add('hidden');
                        }
                    });



                    function showWarrantyFormAnalysis(data, ticketId) {
                        const analysis = data.analysis;
                        const suggestions = data.suggestions;

                        let statusColor = analysis.is_warranty_form ? 'green' : 'red';
                        let statusText = analysis.is_warranty_form ? 'Warranty Form Detected' : 'Not a Warranty Form';

                        const modalContent = `
                <div class="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50" id="warrantyAnalysisModal">
                    <div class="bg-white rounded-lg shadow-xl max-w-2xl w-full mx-4">
                        <div class="px-6 py-4 border-b border-gray-200">
                            <h3 class="text-lg font-semibold text-gray-900 flex items-center">
                                <i class="fas fa-robot mr-2 text-blue-600"></i>
                                AI Warranty Form Analysis
                            </h3>
                        </div>
                        
                        <div class="p-6">
                            <div class="mb-4">
                                <div class="flex items-center mb-2">
                                    <span class="px-3 py-1 rounded-full text-sm font-medium bg-${statusColor}-100 text-${statusColor}-800">
                                        ${statusText}
                                    </span>
                                    <span class="ml-3 text-sm text-gray-600">Confidence: ${analysis.confidence}%</span>
                                </div>
                            </div>
                            
                            <div class="bg-gray-50 rounded-lg p-4 mb-4">
                                <h4 class="font-medium text-gray-700 mb-2">Analysis Details:</h4>
                                <ul class="text-sm text-gray-600 space-y-1">
                                    <li>â€¢ Valid file type: ${analysis.analysis.valid_file_type ? 'Yes' : 'No'}</li>
                                    <li>â€¢ Contains warranty keywords: ${analysis.analysis.has_warranty_keywords ? 'Yes' : 'No'}</li>
                                    ${analysis.analysis.detected_keywords && analysis.analysis.detected_keywords.length > 0
                                ? `<li>â€¢ Detected keywords: ${analysis.analysis.detected_keywords.join(', ')}</li>`
                                : ''}
                                </ul>
                            </div>
                            
                            ${analysis.is_warranty_form ? `
                                <div class="bg-green-50 border border-green-200 rounded-lg p-4 mb-4">
                                    <h4 class="font-medium text-green-800 mb-2">AI Recommendation:</h4>
                                    <p class="text-sm text-green-700">Update ticket status to "Warranty Form Received"</p>
                                </div>
                                
                                <div class="space-y-3">
                                    <p class="text-sm text-gray-700">Is this analysis correct?</p>
                                    <div class="flex space-x-3">
                                        <button onclick="confirmWarrantyForm('${ticketId}', true)" 
                                                class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition">
                                            <i class="fas fa-check mr-2"></i>Yes, Correct
                                        </button>
                                        <button onclick="confirmWarrantyForm('${ticketId}', false)" 
                                                class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition">
                                            <i class="fas fa-times mr-2"></i>No, Incorrect
                                        </button>
                                    </div>
                                </div>
                            ` : `
                                <div class="bg-orange-50 border border-orange-200 rounded-lg p-4 mb-4">
                                    <h4 class="font-medium text-orange-800 mb-2">Manual Review Required:</h4>
                                    <p class="text-sm text-orange-700">AI couldn't confidently identify this as a warranty form. Please review manually.</p>
                                </div>
                                
                                <div class="space-y-3">
                                    <p class="text-sm text-gray-700">Is this actually a warranty form?</p>
                                    <div class="flex space-x-3">
                                        <button onclick="confirmWarrantyForm('${ticketId}', true)" 
                                                class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition">
                                            <i class="fas fa-check mr-2"></i>Yes, It's a Warranty Form
                                        </button>
                                        <button onclick="confirmWarrantyForm('${ticketId}', false)" 
                                                class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition">
                                            <i class="fas fa-times mr-2"></i>No, It's Not
                                        </button>
                                    </div>
                                </div>
                            `}
                        </div>
                        
                        <div class="px-6 py-4 border-t border-gray-200 flex justify-end">
                            <button onclick="closeWarrantyAnalysisModal()" 
                                    class="px-4 py-2 text-gray-700 bg-gray-100 hover:bg-gray-200 rounded-lg transition">
                                Close
                            </button>
                        </div>
                    </div>
                </div>
            `;

                        document.body.insertAdjacentHTML('beforeend', modalContent);
                    }

                    async function confirmWarrantyForm(ticketId, isCorrect) {
                        try {
                            const response = await fetch(`/api/tickets/${ticketId}/confirm-warranty-form`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    is_correct: isCorrect,
                                    feedback: isCorrect ? 'User confirmed AI detection' : 'User rejected AI detection'
                                })
                            });

                            const data = await response.json();

                            if (data.status === 'success') {
                                showNotification(data.message, 'success');
                                closeWarrantyAnalysisModal();

                                if (isCorrect && data.new_status) {
                                    // Optionally reload the page to show updated status
                                    // PERFORMANCE FIX: Reduced reload delay
                                    setTimeout(() => window.location.reload(), 3000);
                                }
                            } else {
                                showNotification(data.message || 'Confirmation failed', 'error');
                            }
                        } catch (error) {
                            console.error('Error confirming warranty form:', error);
                            showNotification('Confirmation failed', 'error');
                        }
                    }

                    function closeWarrantyAnalysisModal() {
                        const modal = document.getElementById('warrantyAnalysisModal');
                        if (modal) {
                            modal.remove();
                        }
                    }

                    // Email Template Functionality
                    document.addEventListener('DOMContentLoaded', function () {
                        const emailTemplateBtn = document.getElementById('emailTemplateBtn');
                        const emailTemplateModal = document.getElementById('emailTemplateModal');
                        const closeEmailTemplateModal = document.getElementById('closeEmailTemplateModal');
                        const cancelEmailTemplate = document.getElementById('cancelEmailTemplate');
                        const loadTemplate = document.getElementById('loadTemplate');
                        const editTemplate = document.getElementById('editTemplate');
                        const clearFields = document.getElementById('clearFields');
                        const sendEmail = document.getElementById('sendEmail');
                        const templateTypeSelect = document.getElementById('templateTypeSelect');
                        const emailSubject = document.getElementById('emailSubject');
                        const emailBody = document.getElementById('emailBody');
                        const availableAttachments = document.getElementById('availableAttachments');

                        let currentTemplateData = null;

                        // Open email template modal - with null check
                        if (emailTemplateBtn) {
                            emailTemplateBtn.addEventListener('click', function () {
                                openModal('emailTemplateModal');
                                resetEmailTemplateForm();

                                // Clear attachments initially - they will only be populated after clicking "Load Template"
                                if (availableAttachments) {
                                    availableAttachments.innerHTML = '<p class="text-sm text-gray-500">Click "Load Template" to see available attachments.</p>';
                                }

                                // ðŸš€ FIXED: Common documents should NEVER load in email template modal
                                // They are completely separate systems and should not interfere
                                console.log('ðŸš€ BLOCKED: Common documents prevented from loading in email template modal');

                                // Focus on subject field after modal opens
                                setTimeout(() => {
                                    if (emailSubject) emailSubject.focus();
                                }, 100);
                            });
                        } else {
                            console.warn('âš ï¸ emailTemplateBtn not found - email template functionality disabled');
                        }

                        // Close modal handlers - with null checks
                        if (closeEmailTemplateModal) {
                            closeEmailTemplateModal.addEventListener('click', () => {
                                closeModal('emailTemplateModal');
                            });
                        }
                        if (cancelEmailTemplate) {
                            cancelEmailTemplate.addEventListener('click', () => {
                                closeModal('emailTemplateModal');
                            });
                        }

                        // Close modal on outside click - with null check
                        if (emailTemplateModal) {
                            emailTemplateModal.addEventListener('click', (e) => {
                                if (e.target === emailTemplateModal) {
                                    closeModal('emailTemplateModal');
                                }
                            });
                        }

                        // Load template button - with null check
                        if (loadTemplate) {
                            loadTemplate.addEventListener('click', async function () {
                                const templateType = templateTypeSelect ? templateTypeSelect.value : '';
                                const ticketId = '{{ ticket.ticket_id }}';

                                if (!templateType) {
                                    showNotification('Please select a template type', 'error');
                                    return;
                                }

                                try {
                                    // Show loading
                                    loadTemplate.disabled = true;
                                    loadTemplate.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Loading...';

                                    const response = await fetch(`/api/email-template/${templateType}/${ticketId}`);
                                    const data = await response.json();

                                    if (response.ok && data.status === 'success') {
                                        currentTemplateData = data.template;

                                        // ðŸš€ CRITICAL DEBUGGING: Log exactly what we received from backend
                                        console.log('ðŸš€ CRITICAL DEBUG: Received template data from backend:', data);
                                        console.log('ðŸš€ CRITICAL DEBUG: Template attachments:', currentTemplateData.attachments);
                                        console.log('ðŸš€ CRITICAL DEBUG: Template data structure:', currentTemplateData);

                                        // Populate form fields
                                        if (emailSubject) emailSubject.value = currentTemplateData.subject;
                                        if (emailBody) emailBody.value = currentTemplateData.body;

                                        // Make fields editable
                                        if (emailSubject) emailSubject.removeAttribute('readonly');
                                        if (emailBody) emailBody.removeAttribute('readonly');

                                        // Update visual styling to show fields are editable
                                        if (emailSubject) emailSubject.classList.add('bg-white', 'cursor-text');
                                        if (emailBody) emailBody.classList.add('bg-white', 'cursor-text');

                                        // Show edit template button
                                        if (editTemplate) editTemplate.style.display = 'inline-block';

                                        // Populate attachments
                                        populateAttachments(currentTemplateData.attachments);

                                        // Enable send button
                                        if (sendEmail) sendEmail.disabled = false;

                                        // Show different notification and indicator based on content source
                                        if (currentTemplateData.has_draft && currentTemplateData.content_source === 'draft') {
                                            showNotification('âœ‰ï¸ Draft email content loaded successfully', 'success');

                                            // Add a visual indicator that this is draft content
                                            const draftIndicator = document.createElement('div');
                                            draftIndicator.id = 'draftIndicator';
                                            draftIndicator.className = 'bg-blue-50 border border-blue-200 rounded-lg p-3 mb-4';
                                            draftIndicator.innerHTML = `
                                    <div class="flex items-center">
                                        <i class="fas fa-edit text-blue-600 mr-2"></i>
                                        <span class="text-blue-800 font-medium">Draft Content Loaded</span>
                                        <span class="text-blue-600 text-sm ml-2">- This email contains pre-written draft content from the original ticket</span>
                                    </div>
                                `;

                                            // Insert before email body
                                            if (emailBody) {
                                                const emailBodyContainer = emailBody.parentNode;
                                                const existingIndicator = document.getElementById('draftIndicator');
                                                if (existingIndicator) {
                                                    existingIndicator.remove();
                                                }
                                                emailBodyContainer.insertBefore(draftIndicator, emailBody);
                                            }
                                        } else {
                                            showNotification('ðŸ“ Template loaded successfully!', 'success');

                                            // Remove draft indicator if it exists
                                            const existingIndicator = document.getElementById('draftIndicator');
                                            if (existingIndicator) {
                                                existingIndicator.remove();
                                            }
                                        }
                                    } else {
                                        showNotification(data.message || 'Failed to load template', 'error');
                                    }
                                } catch (error) {
                                    console.error('Error loading template:', error);
                                    showNotification('Error loading template', 'error');
                                } finally {
                                    // Reset button
                                    loadTemplate.disabled = false;
                                    loadTemplate.innerHTML = '<i class="fas fa-download mr-2"></i>Load Template';
                                }
                            });
                        }

                        // Regenerate attachments button
                        const regenerateAttachments = document.getElementById('regenerateAttachments');
                        if (regenerateAttachments) {
                            regenerateAttachments.addEventListener('click', async function () {
                                const ticketId = '{{ ticket.ticket_id }}';

                                try {
                                    // Show loading
                                    regenerateAttachments.disabled = true;
                                    regenerateAttachments.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Regenerating...';

                                    const response = await fetch(`/api/tickets/${ticketId}/regenerate-attachments`, {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/json',
                                        }
                                    });

                                    const data = await response.json();

                                    if (response.ok) {
                                        if (data.status === 'success') {
                                            showNotification('âœ… Attachments regenerated successfully! You can now click "Load Template" to see them.', 'success');
                                        } else if (data.status === 'warning') {
                                            showNotification('â„¹ï¸ ' + data.message, 'info');
                                        } else {
                                            showNotification('âš ï¸ ' + data.message, 'warning');
                                        }
                                    } else {
                                        showNotification('âŒ ' + (data.message || 'Failed to regenerate attachments'), 'error');
                                    }

                                } catch (error) {
                                    console.error('Error regenerating attachments:', error);
                                    showNotification('âŒ Error regenerating attachments', 'error');
                                } finally {
                                    // Reset button
                                    regenerateAttachments.disabled = false;
                                    regenerateAttachments.innerHTML = '<i class="fas fa-sync-alt mr-2"></i>Regenerate Attachments';
                                }
                            });
                        }

                        // Debug attachments button (for troubleshooting)
                        const debugAttachments = document.getElementById('debugAttachments');
                        if (debugAttachments) {
                            debugAttachments.addEventListener('click', async function () {
                                const ticketId = '{{ ticket.ticket_id }}';

                                try {
                                    // Show loading
                                    debugAttachments.disabled = true;
                                    debugAttachments.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Debugging...';

                                    const response = await fetch(`/api/debug/attachments/${ticketId}`);
                                    const data = await response.json();

                                    if (response.ok && data.status === 'success') {
                                        console.log('ðŸ” DEBUG ATTACHMENTS DATA:', data.debug_info);

                                        // Show debug info in a notification
                                        const debugInfo = data.debug_info;
                                        const summary = `Ticket: ${debugInfo.ticket_id}
Main Attachments: ${debugInfo.main_attachments_count}
Metadata Attachments: ${debugInfo.metadata_attachments_count}
Common Documents: ${debugInfo.common_documents_count}
Source: ${debugInfo.ticket_source.processing_method}
Email Ticket: ${debugInfo.ticket_source.is_email_ticket}`;

                                        showNotification(`ðŸ” Debug Info: ${summary}`, 'info');

                                        // Log detailed info to console for developers
                                        console.log('ðŸ“Š DETAILED DEBUG INFO:', debugInfo);
                                    } else {
                                        showNotification(data.message || 'Failed to debug attachments', 'error');
                                    }
                                } catch (error) {
                                    console.error('Error debugging attachments:', error);
                                    showNotification('Error debugging attachments', 'error');
                                } finally {
                                    // Reset button
                                    debugAttachments.disabled = false;
                                    debugAttachments.innerHTML = '<i class="fas fa-bug mr-2"></i>Debug Attachments';
                                }
                            });
                        }

                        // Edit template button - with null check
                        if (editTemplate) {
                            editTemplate.addEventListener('click', function () {
                                // Make fields editable if they aren't already
                                if (emailSubject) emailSubject.removeAttribute('readonly');
                                if (emailBody) emailBody.removeAttribute('readonly');

                                // Update visual styling to show fields are editable
                                if (emailSubject) emailSubject.classList.add('bg-white', 'cursor-text');
                                if (emailBody) emailBody.classList.add('bg-white', 'cursor-text');

                                // Focus on subject field
                                if (emailSubject) emailSubject.focus();

                                // Show notification
                                showNotification('âœï¸ Template is now editable! You can modify the subject and body.', 'info');

                                // Hide edit button since we're already editing
                                editTemplate.style.display = 'none';
                            });
                        }


                        // Clear fields button - with null check
                        if (clearFields) {
                            clearFields.addEventListener('click', function () {
                                // Clear the fields
                                if (emailSubject) emailSubject.value = '';
                                if (emailBody) emailBody.value = '';

                                // Clear attachments and show message
                                if (availableAttachments) availableAttachments.innerHTML = '<p class="text-sm text-gray-500">Click "Load Template" to see available attachments.</p>';

                                // Focus on subject field
                                if (emailSubject) emailSubject.focus();

                                // Show notification
                                showNotification('ðŸ§¹ Fields cleared! You can now enter new content.', 'info');

                                // Hide edit button if it was showing
                                if (editTemplate) editTemplate.style.display = 'none';

                                // Reset template data
                                currentTemplateData = null;
                            });
                        }

                        // Make fields interactive when user starts typing - with null checks
                        if (emailSubject) {
                            emailSubject.addEventListener('input', function () {
                                // Ensure field is editable
                                this.removeAttribute('readonly');
                                this.classList.add('bg-white', 'cursor-text');

                                // Add visual feedback for active editing

                                // Auto-scroll to keep the field in view
                                this.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            });

                            // Enhanced scrolling for email body
                            emailBody.addEventListener('input', function () {
                                // Ensure field is editable
                                this.removeAttribute('readonly');
                                this.classList.add('bg-white', 'cursor-text');

                                // Auto-scroll to keep the field in view when typing
                                this.scrollIntoView({ behavior: 'smooth', block: 'center' });

                                // Auto-resize textarea
                                this.style.height = 'auto';
                                this.style.height = Math.min(this.scrollHeight, 300) + 'px';
                            });

                            // Enhanced focus management for better UX
                            emailSubject.addEventListener('focus', function () {
                                this.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                this.parentElement.classList.add('ring-2', 'ring-green-200');
                            });

                            emailSubject.addEventListener('blur', function () {
                                this.parentElement.classList.remove('ring-2', 'ring-green-200');
                            });

                            emailBody.addEventListener('focus', function () {
                                this.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                this.parentElement.classList.add('ring-2', 'ring-green-200');
                            });

                            emailBody.addEventListener('blur', function () {
                                this.parentElement.classList.remove('ring-2', 'ring-green-200');
                            });

                            // Enhanced template type selection
                            templateTypeSelect.addEventListener('change', function () {
                                // Clear form when template type changes
                                emailSubject.value = '';
                                emailBody.value = '';
                                availableAttachments.innerHTML = '<p class="text-sm text-gray-500">Select a template type and click "Load Template" to see available attachments.</p>';

                                // Show notification
                                showNotification('ðŸ”„ Template type changed. Please load the new template.', 'info');

                                // Hide edit button
                                editTemplate.style.display = 'none';

                                // Reset template data
                                currentTemplateData = null;
                            });

                            // Keyboard shortcuts for better accessibility
                            document.addEventListener('keydown', function (e) {
                                // Only apply when email template modal is open
                                if (emailTemplateModal.classList.contains('active')) {
                                    // Ctrl/Cmd + Enter to send email
                                    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                                        e.preventDefault();
                                        sendEmail.click();
                                    }

                                    // Escape to close modal
                                    if (e.key === 'Escape') {
                                        e.preventDefault();
                                        closeModal('emailTemplateModal');
                                    }

                                    // Tab navigation enhancement
                                    if (e.key === 'Tab') {
                                        // Ensure smooth scrolling when tabbing through fields
                                        setTimeout(() => {
                                            const activeElement = document.activeElement;
                                            if (activeElement && activeElement.closest('.email-template-content')) {
                                                activeElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                            }
                                        }, 50);
                                    }
                                }
                            });

                            // Send email button - ANTI-SPAM PROTECTION ADDED
                            sendEmail.addEventListener('click', async function () {
                                // Allow sending with custom content even without loading template
                                // if (!currentTemplateData) {
                                //     showNotification('Please load a template first', 'error');
                                //     return;
                                // }

                                // PREVENT MULTIPLE SUBMISSIONS
                                if (sendEmail.disabled) {
                                    console.log('âŒ EMAIL TEMPLATE BLOCKED - Already sending');
                                    return;
                                }

                                // Validate required fields
                                if (!emailSubject.value.trim()) {
                                    showNotification('Please enter an email subject', 'error');
                                    emailSubject.focus();
                                    return;
                                }

                                if (!emailBody.value.trim()) {
                                    showNotification('Please enter an email body', 'error');
                                    emailBody.focus();
                                    return;
                                }

                                // ðŸš€ FIXED: Get selected attachments with proper file data handling
                                const selectedAttachments = [];
                                const checkboxes = availableAttachments.querySelectorAll('input[type="checkbox"]:checked');
                                checkboxes.forEach(checkbox => {
                                    const isCommonDocument = checkbox.dataset.isCommonDocument === 'true';
                                    const documentId = checkbox.dataset.documentId;
                                    const hasFileData = checkbox.dataset.hasData === 'true';
                                    const fileData = checkbox.dataset.fileData || '';

                                    // Determine the correct file path based on attachment type
                                    let correctFilePath = checkbox.dataset.filePath || checkbox.dataset.key || '';
                                    if (isCommonDocument && documentId) {
                                        correctFilePath = `/api/common-documents/${documentId}/download`;
                                    }

                                    // ðŸš€ CRITICAL FIX: Validate file data before sending
                                    if (!hasFileData || !fileData || fileData.length < 10) {
                                        console.warn(`âš ï¸ ATTACHMENT HAS NO VALID FILE DATA: ${checkbox.dataset.name}`);
                                        console.warn(`âš ï¸ File data length: ${fileData ? fileData.length : 0}`);
                                        console.warn(`âš ï¸ Has data flag: ${hasFileData}`);
                                    }

                                    const attachmentData = {
                                        name: checkbox.dataset.name,
                                        file_path: correctFilePath,
                                        key: checkbox.dataset.key || '',
                                        ticket_index: checkbox.dataset.ticketIndex ? parseInt(checkbox.dataset.ticketIndex) : null,
                                        fileData: fileData,  // ðŸš€ FIXED: Include the actual file data
                                        size: parseInt(checkbox.dataset.size) || 0,
                                        type: checkbox.dataset.type || 'file',
                                        is_common_document: isCommonDocument,
                                        document_id: documentId || null,
                                        has_data: hasFileData  // ðŸš€ ADDED: Flag to indicate if file has real data
                                    };

                                    console.log('ðŸ“Ž SELECTED EMAIL TEMPLATE ATTACHMENT:', {
                                        name: attachmentData.name,
                                        hasFileData: hasFileData,
                                        fileDataLength: fileData ? fileData.length : 0,
                                        size: attachmentData.size,
                                        type: attachmentData.type
                                    });
                                    selectedAttachments.push(attachmentData);
                                });

                                // Disable button during processing
                                sendEmail.disabled = true;
                                sendEmail.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Sending...';

                                console.log('ðŸš€ EMAIL TEMPLATE SUBMISSION - Starting');

                                try {
                                    // Prepare email data
                                    const emailData = {
                                        ticket_id: '{{ ticket.ticket_id }}',
                                        template_type: 'warranty',
                                        custom_subject: emailSubject.value,
                                        custom_body: emailBody.value,
                                        attachments: selectedAttachments
                                    };

                                    console.log('ðŸ“§ EMAIL DATA:', emailData);

                                    // Send to API endpoint
                                    const ticketId = '{{ ticket.ticket_id }}';
                                    const response = await fetch(`/api/tickets/${ticketId}/send-email`, {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/json',
                                        },
                                        body: JSON.stringify(emailData)
                                    });

                                    if (response.ok) {
                                        const result = await response.json();
                                        console.log('âœ… EMAIL TEMPLATE SUCCESS:', result);
                                        showNotification('Email sent successfully! ðŸ“§', 'success');

                                        // Close modal first
                                        closeModal('emailTemplateModal');

                                        // Refresh the page to show the new email in conversation section
                                        setTimeout(() => {
                                            window.location.reload();
                                        }, 1000);

                                    } else {
                                        // Fallback to placeholder behavior if API not implemented
                                        console.log('ðŸ“§ EMAIL TEMPLATE PLACEHOLDER - API not yet implemented');
                                        showNotification('Email template prepared! (Integration with email service required for actual sending)', 'success');
                                        closeModal('emailTemplateModal');
                                    }

                                } catch (error) {
                                    console.error('âŒ EMAIL TEMPLATE ERROR:', error);
                                    // Fallback to placeholder behavior
                                    showNotification('Email template prepared! (Integration with email service required for actual sending)', 'success');
                                    closeModal('emailTemplateModal');
                                } finally {
                                    // Reset button after delay to prevent spam
                                    setTimeout(() => {
                                        sendEmail.disabled = false;
                                        sendEmail.innerHTML = '<i class="fas fa-paper-plane mr-2"></i>Send Email';
                                        console.log('ðŸ”„ EMAIL TEMPLATE RESET - Ready for next send');
                                    }, 2000);
                                }
                            });
                        } // End if (emailSubject)

                        // Priority selection functionality
                        const prioritySelect = document.getElementById('prioritySelect');
                        if (prioritySelect) {
                            // Store initial value for reverting on error
                            prioritySelect.dataset.previousPriority = prioritySelect.value;

                            prioritySelect.addEventListener('change', async function () {
                                const newPriority = this.value;
                                const ticketId = this.dataset.ticketId;

                                try {
                                    const response = await fetch(`/api/tickets/${ticketId}/priority`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ priority: newPriority })
                                    });

                                    const data = await response.json();
                                    if (response.ok && data.status === 'success') {
                                        showNotification(`Priority updated to ${newPriority}`, 'success');

                                        // Update the priority badge display in real-time
                                        const priorityBadge = document.querySelector('.ticket-header .px-3.py-1.text-xs.rounded-lg.font-medium');
                                        if (priorityBadge) {
                                            // Update text content
                                            priorityBadge.textContent = '';

                                            // Update icon and text based on new priority
                                            let iconClass, bgClass, textClass;
                                            if (newPriority === 'Urgent') {
                                                iconClass = 'fas fa-exclamation-triangle';
                                                bgClass = 'bg-red-100';
                                                textClass = 'text-red-800';
                                            } else if (newPriority === 'High') {
                                                iconClass = 'fas fa-exclamation';
                                                bgClass = 'bg-orange-100';
                                                textClass = 'text-orange-800';
                                            } else if (newPriority === 'Medium') {
                                                iconClass = 'fas fa-circle';
                                                bgClass = 'bg-yellow-100';
                                                textClass = 'text-yellow-800';
                                            } else if (newPriority === 'Low') {
                                                iconClass = 'fas fa-check';
                                                bgClass = 'bg-green-100';
                                                textClass = 'text-green-800';
                                            }

                                            // Update badge content and styling
                                            priorityBadge.innerHTML = `<i class="${iconClass} mr-1"></i>${newPriority}`;
                                            priorityBadge.className = `px-3 py-1 text-xs rounded-lg font-medium ${bgClass} ${textClass}`;
                                        }

                                        // Update the select styling based on new priority
                                        this.className = this.className.replace(/bg-\w+-100 text-\w+-800/g, '');
                                        this.classList.add('px-3', 'py-1', 'text-xs', 'rounded-full', 'font-medium', 'border-none', 'bg-transparent', 'appearance-none', 'cursor-pointer', 'hover:opacity-80', 'transition');
                                        if (newPriority === 'Urgent') {
                                            this.classList.add('bg-red-100', 'text-red-800');
                                        } else if (newPriority === 'High') {
                                            this.classList.add('bg-orange-100', 'text-orange-800');
                                        } else if (newPriority === 'Medium') {
                                            this.classList.add('bg-yellow-100', 'text-yellow-800');
                                        } else if (newPriority === 'Low') {
                                            this.classList.add('bg-green-100', 'text-green-800');
                                        }

                                        // Store new value as previous for future error handling
                                        this.dataset.previousPriority = newPriority;

                                    } else {
                                        showNotification(data.message || 'Error updating priority', 'error');
                                        // Revert to previous value without page reload
                                        this.value = this.dataset.previousPriority || 'Medium';
                                    }
                                } catch (error) {
                                    console.error('Error updating priority:', error);
                                    showNotification('An error occurred while updating priority', 'error');
                                    // Revert to previous value without page reload
                                    this.value = this.dataset.previousPriority || 'Medium';
                                }
                            });
                        }

                        // Technician assignment functionality
                        const technicianSelect = document.getElementById('technicianSelect');
                        if (technicianSelect) {
                            // Store initial value for reverting on error
                            technicianSelect.dataset.previousTechnician = technicianSelect.value;

                            console.log('ðŸ”§ Technician select element found:', technicianSelect);
                            console.log('ðŸ”§ Available technicians:', Array.from(technicianSelect.options).map(opt => ({ value: opt.value, text: opt.text })));

                            technicianSelect.addEventListener('change', async function () {
                                const newTechnicianId = this.value;
                                const ticketId = this.dataset.ticketId;

                                console.log(`ðŸ”§ Assigning technician ${newTechnicianId} to ticket ${ticketId}`);

                                try {
                                    const response = await fetch(`/api/tickets/${ticketId}/technician`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ technician_id: newTechnicianId })
                                    });

                                    console.log(`ðŸ“¡ Response status: ${response.status}`);
                                    const data = await response.json();
                                    console.log(`ðŸ“‹ Response data:`, data);

                                    if (response.ok && data.status === 'success') {
                                        if (newTechnicianId) {
                                            const selectedOption = this.options[this.selectedIndex];
                                            const technicianName = selectedOption.text.replace('ðŸ”§ ', '').split(' (')[0];
                                            console.log(`âœ… Technician name extracted: ${technicianName}`);
                                            showNotification(`Technician assigned: ${technicianName}`, 'success');

                                            // Update the select styling
                                            this.className = this.className.replace(/bg-\w+-100 text-\w+-800/g, '');
                                            this.classList.add('px-3', 'py-1', 'text-xs', 'rounded-full', 'font-medium', 'border-none', 'bg-transparent', 'appearance-none', 'cursor-pointer', 'hover:opacity-80', 'transition', 'bg-indigo-100', 'text-indigo-800');

                                            // Update technician display in real-time
                                            const technicianDisplay = document.querySelector('.detail-card .text-gray-800.font-semibold');
                                            if (technicianDisplay && technicianDisplay.textContent.includes('{{ technician or "No Technician" }}')) {
                                                technicianDisplay.textContent = technicianName;
                                            }

                                            // Update technician info section if it exists
                                            const technicianInfoSection = document.querySelector('.detail-card .text-gray-600.text-xs');
                                            if (technicianInfoSection) {
                                                const selectedOption = this.options[this.selectedIndex];
                                                const technicianRole = selectedOption.text.match(/\((.*?)\)/)?.[1] || 'Technician';
                                                technicianInfoSection.innerHTML = `<i class="fas fa-id-badge mr-1"></i> ${technicianName} <span class="ml-2 px-2 py-1 bg-indigo-100 text-indigo-800 text-xs rounded-full">${technicianRole}</span>`;
                                            }

                                            // Send immediate update to home page
                                            console.log(`ðŸš€ Sending technician update to home page: ${ticketId} -> ${technicianName}`);
                                            sendTechnicianUpdateToHomePage(ticketId, technicianName);

                                            showNotification(`Technician ${technicianName} assigned successfully!`, 'success');

                                            // Store new value as previous for future error handling
                                            this.dataset.previousTechnician = newTechnicianId;
                                        } else {
                                            showNotification('Technician assignment removed', 'success');

                                            // Update the select styling to default
                                            this.className = this.className.replace(/bg-\w+-100 text-\w+-800/g, '');
                                            this.classList.add('px-3', 'py-1', 'text-xs', 'rounded-full', 'font-medium', 'border-none', 'bg-transparent', 'appearance-none', 'cursor-pointer', 'hover:opacity-80', 'transition', 'bg-gray-100', 'text-gray-800');

                                            // Update technician display in real-time when removed
                                            const technicianDisplay = document.querySelector('.detail-card .text-gray-800.font-semibold');
                                            if (technicianDisplay) {
                                                technicianDisplay.textContent = 'No Technician Assigned';
                                            }

                                            // Update technician info section if it exists
                                            const technicianInfoSection = document.querySelector('.detail-card .text-gray-600.text-xs');
                                            if (technicianInfoSection) {
                                                technicianInfoSection.innerHTML = '<i class="fas fa-user-slash mr-1"></i> No technician assigned';
                                            }

                                            // Send immediate update to home page
                                            console.log(`ðŸš€ Sending technician removal to home page: ${ticketId} -> null`);
                                            sendTechnicianUpdateToHomePage(ticketId, null);

                                            showNotification('Technician assignment removed!', 'success');

                                            // Store new value as previous for future error handling
                                            this.dataset.previousTechnician = '';
                                        }
                                    } else {
                                        showNotification(data.message || 'Error updating technician assignment', 'error');
                                        // Revert to previous value without page reload
                                        this.value = this.dataset.previousTechnician || '';
                                    }
                                } catch (error) {
                                    console.error('Error updating technician assignment:', error);
                                    showNotification('An error occurred while updating technician assignment', 'error');
                                    // Revert to previous value without page reload
                                    this.value = this.dataset.previousTechnician || '';
                                }
                            });
                        } else {
                            console.error('âŒ Technician select element not found!');
                        }

                        // Outcome editing functionality
                        const editOutcomeBtn = document.getElementById('editOutcomeBtn');
                        const outcomeDisplayView = document.getElementById('outcomeDisplayView');
                        const outcomeEditView = document.getElementById('outcomeEditView');
                        const outcomeForm = document.getElementById('outcomeForm');
                        const cancelOutcomeBtn = document.getElementById('cancelOutcomeBtn');

                        // Revisit Fields Toggling Logic (defined early so edit/cancel buttons can call it)
                        const outcomeCategoryDropdown = document.getElementById('outcomeCategory');
                        const revisitFieldsContainer = document.getElementById('revisitFields');
                        const revisitDateInput = document.getElementById('revisitDate');
                        const revisitTechInput = document.getElementById('revisitTechnician');
                        const revisitReasonInput = document.getElementById('revisitReason');

                        function toggleRevisitFields() {
                            if (!outcomeCategoryDropdown || !revisitFieldsContainer) return;
                            if (outcomeCategoryDropdown.value === 'Revisit') {
                                revisitFieldsContainer.classList.remove('hidden');
                                if (revisitDateInput) revisitDateInput.required = true;
                                if (revisitTechInput) revisitTechInput.required = true;
                                if (revisitReasonInput) revisitReasonInput.required = true;
                            } else {
                                revisitFieldsContainer.classList.add('hidden');
                                if (revisitDateInput) revisitDateInput.required = false;
                                if (revisitTechInput) revisitTechInput.required = false;
                                if (revisitReasonInput) revisitReasonInput.required = false;
                            }
                        }

                        // Run on initial load
                        toggleRevisitFields();

                        // Run whenever dropdown value changes
                        if (outcomeCategoryDropdown) {
                            outcomeCategoryDropdown.addEventListener('change', toggleRevisitFields);
                        }

                        if (editOutcomeBtn) {
                            editOutcomeBtn.addEventListener('click', function () {
                                outcomeDisplayView.classList.add('hidden');
                                outcomeEditView.classList.remove('hidden');
                                // Re-trigger visibility check for revisit fields
                                toggleRevisitFields();
                            });
                        }

                        if (cancelOutcomeBtn) {
                            cancelOutcomeBtn.addEventListener('click', function () {
                                outcomeEditView.classList.add('hidden');
                                outcomeDisplayView.classList.remove('hidden');
                            });
                        }
                        if (outcomeForm) {
                            outcomeForm.addEventListener('submit', async function (e) {
                                e.preventDefault();

                                const outcomeCategory = document.getElementById('outcomeCategory').value;
                                const revisitCarriedOut = document.getElementById('revisitCarriedOut').checked;
                                const cleanUnderWarranty = document.getElementById('cleanUnderWarranty').checked;
                                const outcomeNotes = document.getElementById('outcomeNotes').value;

                                // Grab Revisit Extra Fields Data
                                const revisitDate = document.getElementById('revisitDate') ? document.getElementById('revisitDate').value : '';
                                const revisitTechnician = document.getElementById('revisitTechnician') ? document.getElementById('revisitTechnician').value : '';
                                const revisitReason = document.getElementById('revisitReason') ? document.getElementById('revisitReason').value : '';

                                const saveBtn = document.getElementById('saveOutcomeBtn');
                                saveBtn.disabled = true;
                                saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Saving...';

                                try {
                                    const ticketId = '{{ ticket.ticket_id }}';
                                    const response = await fetch(`/api/tickets/${ticketId}/outcome`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({
                                            outcome_category: outcomeCategory,
                                            revisit_carried_out: revisitCarriedOut,
                                            clean_under_warranty: cleanUnderWarranty,
                                            outcome_notes: outcomeNotes,
                                            revisit_date: revisitDate,
                                            revisit_technician_id: revisitTechnician,
                                            revisit_reason: revisitReason
                                        }),
                                        credentials: 'include'
                                    });

                                    const data = await response.json();
                                    if (response.ok && data.status === 'success') {
                                        showNotification('Outcome information updated successfully', 'success');
                                        outcomeDisplayView.classList.remove('hidden');
                                        outcomeEditView.classList.add('hidden');
                                        setTimeout(() => window.location.reload(), 800);
                                    } else {
                                        showNotification(data.message || 'Error updating outcome', 'error');
                                    }
                                } catch (error) {
                                    console.error('Error updating outcome:', error);
                                    showNotification('An error occurred while updating outcome', 'error');
                                } finally {
                                    saveBtn.disabled = false;
                                    saveBtn.innerHTML = '<i class="fas fa-save mr-2"></i>Save Outcome';
                                }
                            });
                        }

                        function resetEmailTemplateForm() {
                            emailSubject.value = '';
                            emailBody.value = '';
                            availableAttachments.innerHTML = '<p class="text-sm text-gray-500">Click "Load Template" to see available attachments.</p>';
                            sendEmail.disabled = false;  // Keep button enabled for direct sending
                            currentTemplateData = null;

                            // Ensure fields are editable by default
                            emailSubject.removeAttribute('readonly');
                            emailBody.removeAttribute('readonly');
                            emailSubject.classList.add('bg-white', 'cursor-text');
                            emailBody.classList.add('bg-white', 'cursor-text');

                            // Hide edit template button initially
                            editTemplate.style.display = 'none';

                            // Clean up draft indicator when form is reset
                            const draftIndicator = document.getElementById('draftIndicator');
                            if (draftIndicator) {
                                draftIndicator.remove();
                            }
                        }

                        // ðŸš€ REMOVED: Function to restore common documents - not needed anymore
                        // Common documents are completely separate from email template functionality

                        function populateAttachments(attachments) {
                            if (!attachments || attachments.length === 0) {
                                availableAttachments.innerHTML = '<p class="text-sm text-gray-500">No attachments available for this ticket.</p>';
                                return;
                            }

                            // ============================================================================
                            // ENHANCED CLIENT-SIDE ATTACHMENT VALIDATION WITH DUPLICATE REMOVAL
                            // ============================================================================

                            console.log('ðŸ”„ REBUILDING ENHANCED CLIENT ATTACHMENT VALIDATION');
                            console.log('ðŸ“¥ Raw attachments received:', attachments);

                            // ðŸš€ ENHANCED DEBUGGING: Log detailed attachment structure
                            attachments.forEach((att, index) => {
                                console.log(`ðŸ“Ž ATTACHMENT ${index + 1} DETAILS:`);
                                console.log(`  - Name: ${att.name || att.filename || 'NO_NAME'}`);
                                console.log(`  - Has fileData: ${!!att.fileData}`);
                                console.log(`  - fileData length: ${att.fileData ? att.fileData.length : 0}`);
                                console.log(`  - Has data: ${!!att.data}`);
                                console.log(`  - data length: ${att.data ? att.data.length : 0}`);
                                console.log(`  - Size: ${att.size || 'NO_SIZE'}`);
                                console.log(`  - Type: ${att.type || 'NO_TYPE'}`);
                                console.log(`  - All keys: ${Object.keys(att)}`);
                            });

                            // CLIENT-SIDE DUPLICATE REMOVAL: Remove duplicates before validation
                            const uniqueAttachments = [];
                            const seenNames = new Set();
                            const seenPaths = new Set();
                            const seenContent = new Set();

                            console.log('ðŸ” CLIENT-SIDE DUPLICATE REMOVAL: Processing attachments for uniqueness');

                            for (const attachment of attachments) {
                                const name = attachment.name || attachment.filename || attachment.fileName || attachment.original_name || '';
                                const path = attachment.file_path || attachment.path || attachment.url || '';
                                const fileData = attachment.fileData || attachment.data || '';
                                const contentHash = `${fileData.length}_${attachment.size || 0}`;

                                // Check for duplicates
                                let isDuplicate = false;

                                if (name && seenNames.has(name)) {
                                    console.log(`ðŸš¨ CLIENT DUPLICATE DETECTED: ${name} - duplicate name`);
                                    isDuplicate = true;
                                } else if (path && seenPaths.has(path)) {
                                    console.log(`ðŸš¨ CLIENT DUPLICATE DETECTED: ${name} - duplicate path: ${path}`);
                                    isDuplicate = true;
                                } else if (fileData && seenContent.has(contentHash)) {
                                    console.log(`ðŸš¨ CLIENT DUPLICATE DETECTED: ${name} - duplicate content`);
                                    isDuplicate = true;
                                }

                                if (!isDuplicate) {
                                    uniqueAttachments.push(attachment);
                                    if (name) seenNames.add(name);
                                    if (path) seenPaths.add(path);
                                    if (fileData) seenContent.add(contentHash);
                                    console.log(`âœ… CLIENT UNIQUE ATTACHMENT: ${name}`);
                                } else {
                                    console.log(`ðŸš¨ CLIENT DUPLICATE REMOVED: ${name}`);
                                }
                            }

                            console.log(`ðŸ“Š CLIENT DUPLICATE REMOVAL: ${uniqueAttachments.length}/${attachments.length} attachments kept`);

                            // Show user notification if duplicates were removed
                            if (uniqueAttachments.length < attachments.length) {
                                const removedCount = attachments.length - uniqueAttachments.length;
                                showNotification(`ðŸ” Removed ${removedCount} duplicate attachment(s) to prevent confusion`, 'info');
                            }

                            function validateClientAttachment(attachment, index) {
                                // Extract name from any possible field
                                const name = attachment.name || attachment.filename || attachment.fileName || attachment.original_name || '';
                                const filePath = attachment.file_path || attachment.path || attachment.url || '';
                                const hasData = attachment.has_data || attachment.data || false;

                                console.log(`ðŸ” Validating attachment ${index}:`, {
                                    name: name,
                                    filePath: filePath,
                                    hasData: hasData,
                                    source: attachment.source || 'unknown'
                                });

                                // RULE 1: Must have a real name (not generic)
                                if (!name || name.trim() === '') {
                                    console.log(`âŒ REJECTED: No name`);
                                    return false;
                                }

                                const nameLower = name.toLowerCase().trim();
                                const fakeNames = ['unknown', 'unknown file', 'unknown_file', 'no name', 'untitled', 'file'];
                                if (fakeNames.includes(nameLower)) {
                                    console.log(`âŒ REJECTED: Fake name '${name}'`);
                                    return false;
                                }

                                // RULE 2: Must have either real data OR valid file path
                                const hasRealData = hasData === true || (attachment.data && attachment.data.length > 10);
                                const hasValidPath = filePath && filePath.trim().length > 3;

                                if (!hasRealData && !hasValidPath) {
                                    console.log(`âŒ REJECTED: No data and no valid path for '${name}'`);
                                    return false;
                                }

                                // RULE 3: If there's a file path, it must not be a status indicator
                                if (hasValidPath) {
                                    const pathLower = filePath.toLowerCase().trim();
                                    const statusWords = [
                                        'detected', 'true', 'false', 'none', 'null', 'undefined', 'empty',
                                        'yes', 'no', 'found', 'present', 'exists', 'valid', 'invalid'
                                    ];
                                    if (statusWords.includes(pathLower)) {
                                        console.log(`âŒ REJECTED: Status indicator path '${filePath}' for '${name}'`);
                                        return false;
                                    }
                                }

                                // RULE 4: Warranty forms must have real file paths or data
                                if (nameLower.includes('warranty') && nameLower.includes('form')) {
                                    if (!hasRealData && !hasValidPath) {
                                        console.log(`âŒ REJECTED: Fake warranty form without data '${name}'`);
                                        return false;
                                    }
                                }

                                console.log(`âœ… VALIDATED: '${name}' passed all checks`);
                                return true;
                            }

                            // Apply bulletproof validation to unique attachments
                            const validAttachments = uniqueAttachments.filter(validateClientAttachment);

                            console.log(`ðŸ“Š ENHANCED VALIDATION SUMMARY: ${validAttachments.length}/${uniqueAttachments.length} unique attachments passed validation`);

                            if (validAttachments.length === 0) {
                                availableAttachments.innerHTML = '<p class="text-sm text-gray-500">No attachments available for this ticket.</p>';
                                return;
                            }

                            const attachmentHTML = validAttachments.map(function (attachment) {
                                // Handle different attachment data structures with safe fallbacks
                                const attachmentName = attachment.name || attachment.filename || attachment.fileName || 'File';
                                const attachmentPath = attachment.file_path || attachment.path || '';
                                const attachmentKey = attachment.key || attachment.id || '';
                                const ticketIndex = attachment.ticket_index !== undefined ? attachment.ticket_index : '';
                                const hasData = attachment.has_data || false;

                                console.log('ðŸ“Ž POPULATING ATTACHMENT:', {
                                    name: attachmentName,
                                    file_path: attachmentPath,
                                    key: attachmentKey,
                                    ticket_index: ticketIndex,
                                    has_data: hasData,
                                    original: attachment
                                });

                                // Add visual indicator for attachments with data
                                const dataIndicator = hasData ? ' âœ…' : ' âš ï¸';

                                // Add manual ticket attachment indicator
                                const manualIndicator = attachment.is_manual_ticket_attachment ? ' ðŸ”§' : '';

                                // Add size indicator
                                const sizeIndicator = attachment.size ? ` (${(attachment.size / 1024).toFixed(1)} KB)` : '';

                                // Determine the correct file path based on attachment type
                                let correctFilePath = attachmentPath;
                                if (attachment.type === 'common-document' && attachment.document_id) {
                                    // For common documents, use the common document download endpoint
                                    correctFilePath = `/api/common-documents/${attachment.document_id}/download`;
                                }

                                // Add tooltip with attachment details
                                const tooltipText = `Type: ${attachment.type || 'file'}\nSize: ${attachment.size || 0} bytes\nHas Data: ${hasData ? 'Yes' : 'No'}\nManual Ticket: ${attachment.is_manual_ticket_attachment ? 'Yes' : 'No'}`;

                                // ðŸš€ FIXED: Properly handle file data for email template attachments
                                const fileData = attachment.fileData || attachment.data || '';
                                const hasFileData = fileData && fileData.length > 10; // Valid base64 data

                                return '<div class="flex items-center space-x-2 p-2 bg-gray-50 rounded hover:bg-gray-100 transition" title="' + tooltipText + '">' +
                                    '<input type="checkbox" id="attachment_' + attachmentName + '" ' +
                                    'data-name="' + attachmentName + '" ' +
                                    'data-file-path="' + correctFilePath + '" ' +
                                    'data-key="' + attachmentKey + '" ' +
                                    'data-ticket-index="' + (attachment.ticket_index || '') + '" ' +
                                    'data-file-data="' + fileData + '" ' +
                                    'data-size="' + (attachment.size || 0) + '" ' +
                                    'data-type="' + (attachment.type || 'file') + '" ' +
                                    'data-document-id="' + (attachment.document_id || '') + '" ' +
                                    'data-is-common-document="' + (attachment.is_common_document || false) + '" ' +
                                    'data-has-data="' + hasFileData + '" ' +
                                    'class="form-checkbox text-green-600" checked>' +
                                    '<label for="attachment_' + attachmentName + '" class="text-sm text-gray-700 flex-1 cursor-help">' +
                                    '<i class="fas fa-paperclip mr-1"></i>' + attachmentName + dataIndicator + manualIndicator + sizeIndicator +
                                    '</label></div>';
                            }).join('');

                            availableAttachments.innerHTML = attachmentHTML;
                        }
                    });

                    // Email attachment functions
                    function downloadEmailAttachment(ticketId, attachmentIndex, fileName) {
                        const url = `/api/tickets/${ticketId}/attachments/${attachmentIndex}/download`;

                        // Create a temporary link to trigger download
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = fileName;
                        link.style.display = 'none';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);

                        showNotification(`Downloading ${fileName}...`, 'success');
                    }

                    function previewEmailAttachment(ticketId, attachmentIndex, fileName) {
                        const url = `/api/tickets/${ticketId}/attachments/${attachmentIndex}/preview`;

                        // Open preview in new window
                        const previewWindow = window.open(url, '_blank', 'width=800,height=600,scrollbars=yes,resizable=yes');

                        if (!previewWindow) {
                            showNotification('Popup blocked. Please allow popups for preview functionality.', 'error');
                            return;
                        }

                        showNotification(`Opening preview for ${fileName}...`, 'success');
                    }

                    // Ticket attachment functions
                    function downloadTicketAttachment(ticketId, attachmentIndex, fileName) {
                        const url = `/api/tickets/${ticketId}/attachments/${attachmentIndex}/download`;

                        console.log(`ðŸ”½ Downloading ticket attachment: ${fileName} from ${url}`);

                        // Show downloading indicator
                        showNotification(`Downloading ${fileName}...`, 'info');

                        // Create a temporary link to trigger download
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = fileName;
                        link.style.display = 'none';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);

                        showNotification(`Download started: ${fileName}`, 'success');

                        // Change button appearance temporarily
                        const button = event.target.closest('button');
                        if (button) {
                            const originalClass = button.className;
                            button.className = 'bg-green-500 text-white px-1.5 py-1 rounded text-[10px] transition';
                            button.innerHTML = '<i class="fas fa-check"></i>';
                            setTimeout(() => {
                                button.className = originalClass;
                                button.innerHTML = '<i class="fas fa-download"></i>';
                            }, 1500);
                        }
                    }

                    function previewTicketAttachment(ticketId, attachmentIndex, fileName) {
                        const url = `/api/tickets/${ticketId}/attachments/${attachmentIndex}/preview`;

                        // Open preview in new window/tab
                        const previewWindow = window.open(url, '_blank', 'width=900,height=700,scrollbars=yes,resizable=yes');

                        if (!previewWindow) {
                            showNotification('Popup blocked. Please allow popups for preview functionality.', 'error');
                            return;
                        }

                        showNotification(`Previewing ${fileName}...`, 'info');

                        // Change button appearance temporarily
                        const button = event.target.closest('button');
                        if (button) {
                            const originalClass = button.className;
                            button.className = 'bg-green-500 text-white px-1.5 py-1 rounded text-[10px] transition';
                            button.innerHTML = '<i class="fas fa-check"></i>';
                            setTimeout(() => {
                                button.className = originalClass;
                                button.innerHTML = '<i class="fas fa-eye"></i>';
                            }, 1500);
                        }
                    }

                    // Unified attachment functions for both reply and ticket attachments
                    function downloadAttachment(replyId, attachmentIndex, fileName, source) {
                        let url;
                        const ticketId = '{{ ticket.ticket_id|e }}';

                        // FIXED: Simplified attachment detection - use reply endpoints for all reply attachments
                        if (replyId && replyId !== 'undefined' && replyId !== 'null') {
                            // This is a reply attachment, use reply endpoint
                            url = `/api/replies/${replyId}/attachments/${parseInt(attachmentIndex)}/download`;
                        } else {
                            // This is a ticket attachment, use ticket endpoint
                            url = `/api/tickets/${ticketId}/attachments/${parseInt(attachmentIndex)}/download`;
                        }

                        // Show downloading indicator
                        showNotification(`Downloading ${fileName}...`, 'info');

                        // First check if the attachment exists and get info
                        fetch(url, { method: 'HEAD' })
                            .then(response => {
                                if (response.ok) {
                                    // Create a temporary link to trigger download
                                    const link = document.createElement('a');
                                    link.href = url;
                                    link.download = fileName;
                                    link.style.display = 'none';
                                    document.body.appendChild(link);
                                    link.click();
                                    document.body.removeChild(link);

                                    showNotification(`Download started: ${fileName}`, 'success');

                                    // Change button appearance temporarily
                                    const button = document.querySelector(`button[onclick*="${fileName}"]`);
                                    if (button) {
                                        const originalClass = button.className;
                                        button.className = 'bg-green-500 text-white px-1.5 py-1 rounded text-[10px] transition';
                                        button.innerHTML = '<i class="fas fa-check"></i>';
                                        setTimeout(() => {
                                            button.className = originalClass;
                                            button.innerHTML = '<i class="fas fa-download"></i>';
                                        }, 1500);
                                    }
                                } else {
                                    // Enhanced error handling with better text_reference support
                                    if (response.status === 400) {
                                        // Try to get detailed error message for text_reference attachments
                                        fetch(url)
                                            .then(errorResponse => errorResponse.json())
                                            .then(errorData => {
                                                if (errorData.attachment_info && errorData.attachment_info.type === 'text_reference') {
                                                    showNotification(`This is a text reference: ${errorData.attachment_info.name}`, 'info');
                                                } else {
                                                    showNotification(`Download failed: ${errorData.error || response.statusText}`, 'error');
                                                }
                                            })
                                            .catch(() => {
                                                showNotification(`Download failed: ${response.statusText}`, 'error');
                                            });
                                    } else if (response.status === 404) {
                                        showNotification(`Attachment not found. Try using the Debug button to check attachment details.`, 'error');
                                    } else if (response.status === 401) {
                                        showNotification(`Authentication required. Please refresh the page and try again.`, 'error');
                                    } else {
                                        showNotification(`Download failed: ${response.statusText}. Try debugging the attachment.`, 'error');
                                    }
                                }
                            })
                            .catch(error => {
                                // Enhanced error handling for network issues
                                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                                    showNotification(`Network error. Please check your connection and try again.`, 'error');
                                } else {
                                    showNotification(`Download error: ${error.message}`, 'error');
                                }
                            });
                    }

                    // Function to update technician tag on home page if it's open in another tab
                    function updateHomePageTechnicianTag(ticketId, technicianName) {
                        try {
                            console.log(`ðŸš€ Starting technician tag update for ticket ${ticketId} -> ${technicianName || 'None'}`);

                            // Method 1: Try to send a message to the home page if it's open
                            if (window.opener && !window.opener.closed) {
                                console.log('ðŸ“¡ Sending message to opener window...');
                                window.opener.postMessage({
                                    type: 'updateTechnicianTag',
                                    ticketId: ticketId,
                                    technicianName: technicianName,
                                    timestamp: Date.now()
                                }, '*');
                            }

                            // Method 2: Also try to send to parent window if this is in an iframe
                            if (window.parent && window.parent !== window) {
                                console.log('ðŸ“¡ Sending message to parent window...');
                                window.parent.postMessage({
                                    type: 'updateTechnicianTag',
                                    ticketId: ticketId,
                                    technicianName: technicianName,
                                    timestamp: Date.now()
                                }, '*');
                            }

                            // Method 3: Try to find other tabs/windows with the same origin
                            console.log('ðŸ“¡ Broadcasting message to all windows...');
                            window.postMessage({
                                type: 'updateTechnicianTag',
                                ticketId: ticketId,
                                technicianName: technicianName,
                                timestamp: Date.now()
                            }, '*');

                            // Method 4: Try to communicate with localStorage for cross-tab communication
                            try {
                                const updateData = {
                                    type: 'updateTechnicianTag',
                                    ticketId: ticketId,
                                    technicianName: technicianName,
                                    timestamp: Date.now()
                                };
                                localStorage.setItem('technicianUpdate', JSON.stringify(updateData));
                                console.log('ðŸ’¾ Stored technician update in localStorage');
                            } catch (localStorageError) {
                                console.log('ðŸ’¾ Could not use localStorage:', localStorageError);
                            }

                            console.log(`âœ… Technician update message sent successfully: ${ticketId} -> ${technicianName || 'None'}`);
                        } catch (error) {
                            console.error('âŒ Error sending technician update message:', error);
                        }
                    }

                    // More reliable function to force refresh home page
                    function forceRefreshHomePage(ticketId, technicianName) {
                        console.log(`ðŸ”„ Force refreshing home page for ticket ${ticketId} -> ${technicianName || 'None'}`);

                        try {
                            // Method 1: Try to refresh the opener window (home page)
                            if (window.opener && !window.opener.closed) {
                                console.log('ðŸ”„ Refreshing opener window (home page)...');
                                window.opener.location.reload();
                                return;
                            }

                            // Method 2: Try to refresh parent window
                            if (window.parent && window.parent !== window) {
                                console.log('ðŸ”„ Refreshing parent window...');
                                window.parent.location.reload();
                                return;
                            }

                            // Method 3: If no other windows, refresh current page after delay
                            console.log('ðŸ”„ No other windows found, refreshing current page in 1 second...');
                            setTimeout(() => {
                                window.location.reload();
                            }, 1000);

                        } catch (error) {
                            console.error('âŒ Error refreshing home page:', error);
                            // Fallback: refresh current page
                            setTimeout(() => {
                                window.location.reload();
                            }, 1000);
                        }
                    }

                    function previewAttachment(replyId, attachmentIndex, fileName, source) {
                        let url;
                        const ticketId = '{{ ticket.ticket_id|e }}';

                        // FIXED: Simplified attachment detection - use reply endpoints for all reply attachments
                        if (replyId && replyId !== 'undefined' && replyId !== 'null') {
                            // This is a reply attachment, use reply endpoint
                            url = `/api/replies/${replyId}/attachments/${parseInt(attachmentIndex)}/preview`;
                        } else {
                            // This is a ticket attachment, use ticket endpoint
                            url = `/api/tickets/${ticketId}/attachments/${parseInt(attachmentIndex)}/preview`;
                        }

                        // First check if the attachment can be previewed
                        fetch(url, { method: 'HEAD' })
                            .then(response => {
                                if (response.ok) {
                                    // Open preview in new window/tab
                                    const previewWindow = window.open(url, '_blank', 'width=900,height=700,scrollbars=yes,resizable=yes');

                                    if (!previewWindow) {
                                        showNotification('Popup blocked. Please allow popups for preview functionality.', 'error');
                                        return;
                                    }

                                    showNotification(`Previewing ${fileName}...`, 'info');

                                    // Change button appearance temporarily
                                    const button = document.querySelector(`button[onclick*="${fileName}"]`);
                                    if (button) {
                                        const originalClass = button.className;
                                        button.className = 'bg-blue-500 text-white px-1.5 py-1 rounded text-[10px] transition';
                                        button.innerHTML = '<i class="fas fa-eye-slash"></i>';
                                        setTimeout(() => {
                                            button.className = originalClass;
                                            button.innerHTML = '<i class="fas fa-eye"></i>';
                                        }, 1500);
                                    }
                                } else {
                                    // Enhanced error handling with better text_reference support
                                    if (response.status === 400) {
                                        // Try to get detailed error message for text_reference attachments
                                        fetch(url)
                                            .then(errorResponse => errorResponse.json())
                                            .then(errorData => {
                                                if (errorData.attachment_info && errorData.attachment_info.type === 'text_reference') {
                                                    showNotification(`This is a text reference: ${errorData.attachment_info.name}`, 'info');
                                                } else {
                                                    showNotification(`File type not supported for preview. Try downloading instead.`, 'error');
                                                }
                                            })
                                            .catch(() => {
                                                showNotification(`File type not supported for preview. Try downloading instead.`, 'error');
                                            });
                                    } else if (response.status === 404) {
                                        showNotification(`Attachment not found. Try using the Debug button to check attachment details.`, 'error');
                                    } else if (response.status === 401) {
                                        showNotification(`Authentication required. Please refresh the page and try again.`, 'error');
                                    } else {
                                        showNotification(`Preview failed: ${response.statusText}. Try debugging the attachment.`, 'error');
                                    }
                                }
                            })
                            .catch(error => {
                                // Enhanced error handling for network issues
                                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                                    showNotification(`Network error. Please check your connection and try again.`, 'error');
                                } else {
                                    showNotification(`Preview error: ${error.message}`, 'error');
                                }
                            });
                    }

                    // Function to handle text reference attachments
                    function handleTextReferenceAttachment(attachmentName, description) {
                        const message = description ? `${attachmentName}: ${description}` : attachmentName;
                        showNotification(`ðŸ“‹ Text Reference: ${message}`, 'info');
                    }



                    // Function to regenerate missing attachments for webhook replies
                    function regenerateWebhookAttachments() {
                        const ticketId = '{{ ticket.ticket_id|e }}';

                        showNotification('Regenerating webhook attachments...', 'info');

                        // Call the webhook-specific regenerate attachments endpoint
                        fetch(`/api/tickets/${ticketId}/regenerate-webhook-attachments`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            }
                        })
                            .then(response => response.json())
                            .then(data => {
                                if (data.status === 'success') {
                                    showNotification('Webhook attachments regenerated successfully! Refreshing page...', 'success');
                                    setTimeout(() => {
                                        window.location.reload();
                                    }, 2000);
                                } else if (data.status === 'warning') {
                                    showNotification(`â„¹ï¸ ${data.message}`, 'info');
                                } else {
                                    showNotification(`Failed to regenerate webhook attachments: ${data.message}`, 'error');
                                }
                            })
                            .catch(error => {
                                console.error('Error regenerating webhook attachments:', error);
                                showNotification('Error regenerating webhook attachments. Please try again.', 'error');
                            });
                    }













                    // Function to send immediate technician update to home page
                    function sendTechnicianUpdateToHomePage(ticketId, technicianName) {
                        console.log(`ðŸš€ Sending technician update: ${ticketId} -> ${technicianName || 'None'}`);

                        try {
                            // Method 1: Send message to opener window (home page)
                            if (window.opener && !window.opener.closed) {
                                console.log('ðŸ“¡ Sending to opener window...');
                                window.opener.postMessage({
                                    type: 'updateTechnicianTag',
                                    ticketId: ticketId,
                                    technicianName: technicianName
                                }, '*');
                            }

                            // Method 2: Send to parent window if in iframe
                            if (window.parent && window.parent !== window) {
                                console.log('ðŸ“¡ Sending to parent window...');
                                window.parent.postMessage({
                                    type: 'updateTechnicianTag',
                                    ticketId: ticketId,
                                    technicianName: technicianName
                                }, '*');
                            }

                            // Method 3: Broadcast to all windows
                            console.log('ðŸ“¡ Broadcasting to all windows...');
                            window.postMessage({
                                type: 'updateTechnicianTag',
                                ticketId: ticketId,
                                technicianName: technicianName
                            }, '*');

                            // Method 4: localStorage backup
                            try {
                                const updateData = {
                                    type: 'updateTechnicianTag',
                                    ticketId: ticketId,
                                    technicianName: technicianName
                                };
                                localStorage.setItem('technicianUpdate', JSON.stringify(updateData));
                                console.log('ðŸ’¾ Stored in localStorage');
                            } catch (localStorageError) {
                                console.log('ðŸ’¾ localStorage failed:', localStorageError);
                            }

                            // Method 5: Force refresh home page if it's open
                            if (window.opener && !window.opener.closed) {
                                console.log('ðŸ”„ Refreshing opener window...');
                                setTimeout(() => {
                                    window.opener.location.reload();
                                }, 1000);
                            }

                            // Method 6: Try to find and update the home page directly if it's in the same window
                            try {
                                const homePageTickets = document.querySelectorAll('.ticket-card');
                                if (homePageTickets.length > 0) {
                                    console.log('ðŸ  Found ticket cards on current page, updating directly...');
                                    // This means we're on the home page, update directly
                                    updateTechnicianTagOnCurrentPage(ticketId, technicianName);
                                }
                            } catch (directError) {
                                console.log('ðŸ  Direct update not possible:', directError);
                            }

                            console.log(`âœ… Technician update sent successfully: ${ticketId} -> ${technicianName || 'None'}`);
                        } catch (error) {
                            console.error('âŒ Error sending technician update:', error);
                        }
                    }

                    // Sidebar toggle functionality - REMOVED DUPLICATE CODE
                    // This functionality is now handled by the enhanced initializeSidebarToggle() function

                    // Initialize sidebar state based on current screen size
                    if (window.innerWidth >= 1921) {
                        rightSidebar.classList.add('ultra-wide-open');
                        if (sidebarToggle) {
                            sidebarToggle.style.display = 'block';
                            sidebarToggle.title = 'Open Sidebar';
                            const icon = sidebarToggle.querySelector('i');
                            if (icon) icon.className = 'fas fa-bars';
                        }
                    } else if (window.innerWidth <= 1280) {
                        if (sidebarToggle) {
                            sidebarToggle.style.display = 'block';
                            sidebarToggle.title = 'Open Sidebar';
                            const icon = sidebarToggle.querySelector('i');
                            if (icon) icon.className = 'fas fa-bars';
                        }
                    } else {
                        if (sidebarToggle) {
                            sidebarToggle.style.display = 'none';
                        }
                    }

                    // Minimize button functionality - removed conflicting listener
                    // The minimize button now properly closes the sidebar via the listener in initializeSidebarToggle()


                    // Function to update technician tag on the current page (if it's the home page)
                    function updateTechnicianTagOnCurrentPage(ticketId, technicianName) {
                        console.log(`ðŸ”§ Updating technician tag on current page for ticket ${ticketId}: ${technicianName || 'None'}`);

                        // Find the ticket card by ticket ID
                        const ticketCard = document.querySelector(`a[href*="/ticket/${ticketId}"]`)?.closest('.ticket-card');
                        if (!ticketCard) {
                            console.log(`âŒ Ticket card not found for ${ticketId}`);
                            return;
                        }

                        // Find or create the technician badge
                        let technicianBadge = ticketCard.querySelector('.technician-badge');

                        if (technicianName) {
                            // Create or update technician badge
                            if (!technicianBadge) {
                                technicianBadge = document.createElement('span');
                                technicianBadge.className = 'technician-badge px-2 py-1 text-xs rounded-full font-medium bg-blue-100 text-blue-800';
                                technicianBadge.innerHTML = `ðŸ‘· ${technicianName}`;

                                // Insert after priority badge
                                const priorityBadge = ticketCard.querySelector('.priority-badge');
                                if (priorityBadge) {
                                    priorityBadge.parentNode.insertBefore(technicianBadge, priorityBadge.nextSibling);
                                } else {
                                    // Fallback: insert at the beginning of badges container
                                    const badgesContainer = ticketCard.querySelector('.flex.flex-wrap.items-center.gap-2');
                                    if (badgesContainer) {
                                        badgesContainer.insertBefore(technicianBadge, badgesContainer.firstChild);
                                    }
                                }
                            } else {
                                technicianBadge.innerHTML = `ðŸ‘· ${technicianName}`;
                            }

                            console.log(`âœ… Technician badge updated for ticket ${ticketId}: ${technicianName}`);
                        } else {
                            // Remove technician badge if it exists
                            if (technicianBadge) {
                                technicianBadge.remove();
                                console.log(`ðŸ—‘ï¸ Technician badge removed for ticket ${ticketId}`);
                            }
                        }
                    }

                    // Enhanced sidebar toggle functionality
                    function initializeSidebarToggle() {
                        const sidebarToggle = document.getElementById('sidebarToggleMobile');
                        const rightSidebar = document.querySelector('.right-sidebar');
                        const sidebarOverlay = document.getElementById('sidebarOverlay');
                        const minimizeBtn = document.getElementById('minimizeBtn');

                        if (!sidebarToggle || !rightSidebar) {
                            console.error('âŒ Sidebar elements not found');
                            console.error('sidebarToggle:', sidebarToggle);
                            console.error('rightSidebar:', rightSidebar);
                            return;
                        }

                        console.log('âœ… Initializing sidebar toggle functionality');
                        console.log('âœ… Sidebar toggle button found:', sidebarToggle);
                        console.log('âœ… Right sidebar found:', rightSidebar);

                        // Sidebar toggle click handler
                        sidebarToggle.addEventListener('click', function (e) {
                            e.preventDefault();
                            e.stopPropagation();

                            console.log('ðŸ”„ Sidebar toggle clicked');
                            console.log('ðŸ”„ Current window width:', window.innerWidth);
                            console.log('ðŸ”„ Current sidebar classes:', rightSidebar.className);

                            // Get main content element for expansion
                            const mainContent = document.querySelector('.main-content');

                            // Check if we're on ultra-wide screen
                            if (window.innerWidth >= 1921) {
                                console.log('ðŸ–¥ï¸ Ultra-wide screen detected - toggling ultra-wide-open class');
                                console.log('ðŸ”„ Before toggle - sidebar classes:', rightSidebar.className);
                                console.log('ðŸ”„ Before toggle - sidebar transform:', rightSidebar.style.transform);

                                rightSidebar.classList.toggle('ultra-wide-open');

                                console.log('ðŸ”„ After toggle - sidebar classes:', rightSidebar.className);
                                console.log('ðŸ”„ After toggle - sidebar transform:', rightSidebar.style.transform);

                                // Update toggle button icon and main content expansion
                                const icon = this.querySelector('i');
                                const appContainer = document.querySelector('.app-container');

                                if (rightSidebar.classList.contains('ultra-wide-open')) {
                                    console.log('âœ… Sidebar is now OPEN - updating UI');
                                    icon.className = 'fas fa-times';
                                    this.title = 'Close Sidebar';

                                    // Force sidebar to be visible with all properties
                                    rightSidebar.style.transform = 'translateX(0)';
                                    rightSidebar.style.visibility = 'visible';
                                    rightSidebar.style.opacity = '1';
                                    rightSidebar.style.display = 'block';
                                    rightSidebar.style.pointerEvents = 'auto';
                                    console.log('âœ… Forced sidebar to be visible with all properties');

                                    // Expand app container when sidebar opens
                                    if (appContainer) {
                                        appContainer.classList.remove('sidebar-closed');
                                        appContainer.classList.add('sidebar-open');
                                        console.log('âœ… App container set to sidebar-open');
                                    }

                                    // Hide the toggle button when sidebar opens
                                    this.classList.add('hidden');
                                    console.log('âœ… Sidebar opened (ultra-wide) - toggle button hidden');
                                } else {
                                    console.log('âœ… Sidebar is now CLOSED - updating UI');
                                    icon.className = 'fas fa-bars';
                                    this.title = 'Open Sidebar';

                                    // Force sidebar to be hidden
                                    rightSidebar.style.transform = 'translateX(150%)';
                                    console.log('âœ… Forced sidebar transform to translateX(150%)');

                                    // Contract app container when sidebar closes
                                    if (appContainer) {
                                        appContainer.classList.remove('sidebar-open');
                                        appContainer.classList.add('sidebar-closed');
                                        console.log('âœ… App container set to sidebar-closed');
                                    }

                                    // Show the toggle button when sidebar closes
                                    this.classList.remove('hidden');
                                    console.log('âœ… Sidebar closed (ultra-wide) - toggle button shown');
                                }
                            } else {
                                // Standard mobile/tablet behavior
                                rightSidebar.classList.toggle('sidebar-open');

                                // Update toggle button icon and main content expansion
                                const icon = this.querySelector('i');
                                const appContainer = document.querySelector('.app-container');

                                if (rightSidebar.classList.contains('sidebar-open')) {
                                    icon.className = 'fas fa-times';
                                    this.title = 'Close Sidebar';

                                    // Force sidebar to be visible with all properties
                                    rightSidebar.style.transform = 'translateX(0)';
                                    rightSidebar.style.visibility = 'visible';
                                    rightSidebar.style.opacity = '1';
                                    rightSidebar.style.display = 'block';
                                    rightSidebar.style.pointerEvents = 'auto';
                                    console.log('âœ… Forced sidebar to be visible with all properties');

                                    // Expand app container when sidebar opens
                                    if (appContainer) {
                                        appContainer.classList.remove('sidebar-closed');
                                        appContainer.classList.add('sidebar-open');
                                    }
                                    if (sidebarOverlay) {
                                        sidebarOverlay.style.display = 'block';
                                        sidebarOverlay.classList.add('active');
                                    }
                                    // Hide the toggle button when sidebar opens
                                    this.classList.add('hidden');
                                    console.log('âœ… Sidebar opened (mobile/tablet) - toggle button hidden');
                                } else {
                                    icon.className = 'fas fa-bars';
                                    this.title = 'Open Sidebar';
                                    // Contract app container when sidebar closes
                                    if (appContainer) {
                                        appContainer.classList.remove('sidebar-open');
                                        appContainer.classList.add('sidebar-closed');
                                    }
                                    if (sidebarOverlay) {
                                        sidebarOverlay.style.display = 'none';
                                        sidebarOverlay.classList.remove('active');
                                    }
                                    // Show the toggle button when sidebar closes
                                    this.classList.remove('hidden');
                                    console.log('âœ… Sidebar closed (mobile/tablet) - toggle button shown');
                                }
                            }
                        });

                        // Overlay click handler
                        if (sidebarOverlay) {
                            sidebarOverlay.addEventListener('click', function () {
                                rightSidebar.classList.remove('sidebar-open');
                                const icon = sidebarToggle.querySelector('i');
                                icon.className = 'fas fa-bars';
                                sidebarToggle.title = 'Open Sidebar';
                                this.style.display = 'none';
                                this.classList.remove('active');

                                // Expand app container to take full width
                                const appContainer = document.querySelector('.app-container');
                                if (appContainer) {
                                    appContainer.classList.remove('sidebar-open');
                                    appContainer.classList.add('sidebar-closed');
                                }

                                // Show the toggle button when sidebar closes
                                sidebarToggle.classList.remove('hidden');

                                console.log('âœ… Sidebar closed via overlay click - toggle button shown');
                            });
                        }

                        // Minimize button click handler - closes the sidebar
                        if (minimizeBtn) {
                            minimizeBtn.addEventListener('click', function () {
                                console.log('ðŸ”„ Minimize button clicked - closing sidebar');

                                // Close sidebar based on screen size
                                if (window.innerWidth >= 1921) {
                                    rightSidebar.classList.remove('ultra-wide-open');
                                } else {
                                    rightSidebar.classList.remove('sidebar-open');
                                    if (sidebarOverlay) {
                                        sidebarOverlay.style.display = 'none';
                                        sidebarOverlay.classList.remove('active');
                                    }
                                }

                                // Expand app container to take full width
                                const appContainer = document.querySelector('.app-container');
                                if (appContainer) {
                                    appContainer.classList.remove('sidebar-open');
                                    appContainer.classList.add('sidebar-closed');
                                }

                                // Show the toggle button when sidebar closes
                                sidebarToggle.classList.remove('hidden');

                                // Reset toggle button icon
                                const icon = sidebarToggle.querySelector('i');
                                if (icon) {
                                    icon.className = 'fas fa-bars';
                                    sidebarToggle.title = 'Open Sidebar';
                                }

                                console.log('âœ… Sidebar closed via minimize button - toggle button shown');
                            });
                        }

                        // Close sidebar when clicking outside on mobile
                        document.addEventListener('click', function (e) {
                            if (window.innerWidth <= 1023) {
                                if (!rightSidebar.contains(e.target) &&
                                    !sidebarToggle.contains(e.target) &&
                                    rightSidebar.classList.contains('sidebar-open')) {

                                    rightSidebar.classList.remove('sidebar-open');
                                    const icon = sidebarToggle.querySelector('i');
                                    icon.className = 'fas fa-bars';
                                    sidebarToggle.title = 'Open Sidebar';
                                    if (sidebarOverlay) {
                                        sidebarOverlay.style.display = 'none';
                                        sidebarOverlay.classList.remove('active');
                                    }

                                    // Expand app container to take full width
                                    const appContainer = document.querySelector('.app-container');
                                    if (appContainer) {
                                        appContainer.classList.remove('sidebar-open');
                                        appContainer.classList.add('sidebar-closed');
                                    }

                                    // Show the toggle button when sidebar closes
                                    sidebarToggle.classList.remove('hidden');

                                    console.log('âœ… Sidebar closed via outside click - toggle button shown');
                                }
                            }
                        });

                        // Enhanced window resize handler for comprehensive screen size coverage
                        window.addEventListener('resize', function () {
                            const mainContent = document.querySelector('.main-content');

                            if (window.innerWidth >= 2560) {
                                // Very large screen (2560px+): enhanced ultra-wide behavior
                                console.log('ðŸ”„ Resize detected: 2560px+ screen - applying ultra-wide behavior');

                                rightSidebar.classList.remove('sidebar-open', 'mobile-open');
                                rightSidebar.classList.add('ultra-wide-open');
                                console.log('âœ… Added ultra-wide-open class to sidebar');

                                // Force sidebar to be hidden initially
                                rightSidebar.style.transform = 'translateX(150%)';
                                console.log('âœ… Forced sidebar transform to translateX(150%)');

                                // Contract app container when sidebar is hidden
                                const appContainer = document.querySelector('.app-container');
                                if (appContainer) {
                                    appContainer.classList.remove('sidebar-open');
                                    appContainer.classList.add('sidebar-closed');
                                    console.log('âœ… App container set to sidebar-closed');
                                }

                                if (sidebarToggle) {
                                    sidebarToggle.classList.remove('hidden');
                                    sidebarToggle.title = 'Open Sidebar (Ultra-Wide)';
                                    const icon = sidebarToggle.querySelector('i');
                                    if (icon) {
                                        icon.className = 'fas fa-bars';
                                    }
                                    console.log('âœ… Toggle button shown and titled for ultra-wide');
                                }
                                console.log('ðŸ”„ Resized to very large screen (2560px+): enhanced sidebar behavior');
                            } else if (window.innerWidth >= 1921) {
                                // Ultra-wide screen: auto-hide sidebar
                                rightSidebar.classList.remove('sidebar-open', 'mobile-open');
                                rightSidebar.classList.add('ultra-wide-open');

                                // Contract app container when sidebar is hidden
                                const appContainer = document.querySelector('.app-container');
                                if (appContainer) {
                                    appContainer.classList.remove('sidebar-open');
                                    appContainer.classList.add('sidebar-closed');
                                }

                                if (sidebarToggle) {
                                    sidebarToggle.classList.remove('hidden');
                                    sidebarToggle.title = 'Open Sidebar';
                                    sidebarToggle.style.width = '56px';
                                    sidebarToggle.style.height = '56px';
                                    sidebarToggle.style.right = '1rem';
                                    const icon = sidebarToggle.querySelector('i');
                                    if (icon) {
                                        icon.className = 'fas fa-bars';
                                        icon.style.fontSize = '1.25rem';
                                    }
                                }
                                console.log('ðŸ”„ Resized to ultra-wide: sidebar hidden');
                            } else if (window.innerWidth >= 1711 && window.innerWidth <= 1920) {
                                // Wide desktop (1711px - 1920px): hide sidebar by default
                                rightSidebar.classList.remove('ultra-wide-open', 'sidebar-open');
                                rightSidebar.style.transform = 'translateX(120%)';

                                // Contract app container when sidebar is hidden
                                const appContainer = document.querySelector('.app-container');
                                if (appContainer) {
                                    appContainer.classList.remove('sidebar-open');
                                    appContainer.classList.add('sidebar-closed');
                                }

                                if (sidebarToggle) {
                                    sidebarToggle.classList.remove('hidden');
                                    sidebarToggle.title = 'Open Sidebar';
                                }
                                console.log('ðŸ”„ Resized to wide desktop (1711px-1920px): sidebar hidden by default - toggle button shown');
                            } else if (window.innerWidth >= 1281 && window.innerWidth <= 1710) {
                                // Standard desktop (1281px - 1710px): hide sidebar by default
                                rightSidebar.classList.remove('ultra-wide-open', 'sidebar-open');
                                rightSidebar.style.transform = 'translateX(120%)';

                                // Contract app container when sidebar is hidden
                                const appContainer = document.querySelector('.app-container');
                                if (appContainer) {
                                    appContainer.classList.remove('sidebar-open');
                                    appContainer.classList.add('sidebar-closed');
                                }

                                if (sidebarToggle) {
                                    sidebarToggle.classList.remove('hidden');
                                    sidebarToggle.title = 'Open Sidebar';
                                }
                                console.log('ðŸ”„ Resized to standard desktop (1281px-1710px): sidebar hidden by default - toggle button shown');
                            } else if (window.innerWidth >= 1025 && window.innerWidth <= 1280) {
                                // Medium desktop: hide sidebar by default but allow toggling
                                rightSidebar.classList.remove('ultra-wide-open', 'sidebar-open');
                                rightSidebar.style.transform = 'translateX(120%)';

                                // Contract app container when sidebar is hidden
                                const appContainer = document.querySelector('.app-container');
                                if (appContainer) {
                                    appContainer.classList.remove('sidebar-open');
                                    appContainer.classList.add('sidebar-closed');
                                }

                                if (sidebarToggle) {
                                    sidebarToggle.classList.remove('hidden');
                                    sidebarToggle.title = 'Open Sidebar';
                                }
                                console.log('ðŸ”„ Resized to medium desktop (1025px-1280px): sidebar hidden by default - toggle button shown');
                            } else if (window.innerWidth >= 769 && window.innerWidth <= 1024) {
                                // Tablet landscape: hide sidebar by default
                                rightSidebar.classList.remove('ultra-wide-open', 'sidebar-open');

                                // Contract app container when sidebar is hidden
                                const appContainer = document.querySelector('.app-container');
                                if (appContainer) {
                                    appContainer.classList.remove('sidebar-open');
                                    appContainer.classList.add('sidebar-closed');
                                }

                                if (sidebarToggle) {
                                    sidebarToggle.classList.remove('hidden');
                                    sidebarToggle.title = 'Open Sidebar';
                                }
                                console.log('ðŸ”„ Resized to tablet landscape (769px-1024px): sidebar hidden - toggle button shown');
                            } else if (window.innerWidth <= 768) {
                                // Mobile/tablet: hide sidebar by default
                                rightSidebar.classList.remove('ultra-wide-open', 'sidebar-open');

                                // Contract app container when sidebar is hidden
                                const appContainer = document.querySelector('.app-container');
                                if (appContainer) {
                                    appContainer.classList.remove('sidebar-open');
                                    appContainer.classList.add('sidebar-closed');
                                }

                                if (sidebarToggle) {
                                    sidebarToggle.classList.remove('hidden');
                                    sidebarToggle.title = 'Open Sidebar';
                                    const icon = sidebarToggle.querySelector('i');
                                    if (icon) {
                                        icon.className = 'fas fa-bars';
                                    }
                                }
                                console.log('ðŸ”„ Resized to mobile/tablet (â‰¤768px): sidebar hidden - toggle button shown');
                            }
                        });

                        // Enhanced initialization for comprehensive screen size coverage
                        const mainContent = document.querySelector('.main-content');

                        console.log('ðŸš€ Initializing sidebar state for screen width:', window.innerWidth);

                        if (window.innerWidth >= 2560) {
                            // Very large screen (2560px+): enhanced ultra-wide behavior
                            console.log('ðŸ–¥ï¸ Detected 2560px+ screen - applying ultra-wide behavior');

                            // Remove any conflicting classes first
                            rightSidebar.classList.remove('sidebar-open', 'mobile-open');

                            // Add ultra-wide-open class
                            rightSidebar.classList.add('ultra-wide-open');
                            console.log('âœ… Added ultra-wide-open class to sidebar');

                            // Contract app container when sidebar is hidden
                            const appContainer = document.querySelector('.app-container');
                            if (appContainer) {
                                appContainer.classList.remove('sidebar-open');
                                appContainer.classList.add('sidebar-closed');
                                console.log('âœ… App container set to sidebar-closed');
                            } else {
                                console.log('âŒ App container not found');
                            }

                            // Show toggle button
                            sidebarToggle.classList.remove('hidden');
                            sidebarToggle.title = 'Open Sidebar (Ultra-Wide)';
                            console.log('âœ… Toggle button shown and titled for ultra-wide');

                            // Force sidebar to be hidden initially
                            rightSidebar.style.transform = 'translateX(150%)';
                            console.log('âœ… Forced sidebar transform to translateX(150%)');

                            console.log('âœ… Initialized for very large screen (2560px+)');
                        } else if (window.innerWidth >= 1025) {
                            // Desktop (>= 1025px): Sidebar ALWAYS VISIBLE
                            rightSidebar.classList.remove('ultra-wide-open');
                            rightSidebar.classList.add('sidebar-open');
                            rightSidebar.style.transform = 'translateX(0)';
                            rightSidebar.style.visibility = 'visible';
                            rightSidebar.style.opacity = '1';
                            rightSidebar.style.display = 'block';

                            // Expand app container
                            const appContainer = document.querySelector('.app-container');
                            if (appContainer) {
                                appContainer.classList.remove('sidebar-closed');
                                appContainer.classList.add('sidebar-open');
                            }

                            // Hide toggle button as it's always open
                            sidebarToggle.classList.add('hidden');
                            console.log('âœ… Initialized for desktop (>= 1025px): Sidebar forced visible');

                        } else if (window.innerWidth >= 769 && window.innerWidth <= 1024) {
                            // Tablet landscape: hidden by default
                            rightSidebar.classList.remove('ultra-wide-open', 'sidebar-open');
                            rightSidebar.style.transform = 'translateX(120%)';

                            // Contract app container
                            const appContainer = document.querySelector('.app-container');
                            if (appContainer) {
                                appContainer.classList.remove('sidebar-open');
                                appContainer.classList.add('sidebar-closed');
                            }

                            sidebarToggle.classList.remove('hidden');
                            sidebarToggle.title = 'Open Sidebar';
                            console.log('âœ… Initialized for tablet: Sidebar hidden');
                        } else if (window.innerWidth <= 768) {
                            // Mobile/tablet: hide sidebar by default
                            rightSidebar.classList.remove('ultra-wide-open', 'sidebar-open');

                            // Contract app container when sidebar is hidden
                            const appContainer = document.querySelector('.app-container');
                            if (appContainer) {
                                appContainer.classList.remove('sidebar-open');
                                appContainer.classList.add('sidebar-closed');
                            }

                            sidebarToggle.classList.remove('hidden');
                            sidebarToggle.title = 'Open Sidebar';
                            console.log('âœ… Initialized for mobile/tablet (â‰¤768px): sidebar hidden - toggle button shown');
                        }

                        console.log('âœ… Sidebar toggle functionality initialized');
                    }

                    // Enhanced test function to verify sidebar toggle is working
                    function testSidebarToggle() {
                        console.log('ðŸ§ª Testing sidebar toggle functionality...');
                        console.log('ðŸ–¥ï¸ Current window width:', window.innerWidth);

                        const sidebarToggle = document.getElementById('sidebarToggleMobile');
                        const rightSidebar = document.querySelector('.right-sidebar');
                        const sidebarOverlay = document.getElementById('sidebarOverlay');
                        const minimizeBtn = document.getElementById('minimizeBtn');

                        console.log('ðŸ” Element search results:');
                        console.log('  - sidebarToggle:', sidebarToggle);
                        console.log('  - rightSidebar:', rightSidebar);
                        console.log('  - sidebarOverlay:', sidebarOverlay);
                        console.log('  - minimizeBtn:', minimizeBtn);

                        if (sidebarToggle) {
                            console.log('âœ… Sidebar toggle button found');
                            console.log('  - ID:', sidebarToggle.id);
                            console.log('  - Classes:', sidebarToggle.className);
                            console.log('  - Display style:', sidebarToggle.style.display);
                            console.log('  - Computed display:', window.getComputedStyle(sidebarToggle).display);
                            console.log('  - Position:', sidebarToggle.style.position);
                            console.log('  - Z-index:', sidebarToggle.style.zIndex);
                            console.log('  - Visible:', sidebarToggle.offsetParent !== null);
                        } else {
                            console.log('âŒ Sidebar toggle button not found');
                        }

                        if (rightSidebar) {
                            console.log('âœ… Right sidebar found');
                            console.log('  - ID:', rightSidebar.id);
                            console.log('  - Classes:', rightSidebar.className);
                            console.log('  - Transform:', rightSidebar.style.transform);
                            console.log('  - Computed transform:', window.getComputedStyle(rightSidebar).transform);
                            console.log('  - Position:', rightSidebar.style.position);
                            console.log('  - Z-index:', rightSidebar.style.zIndex);
                            console.log('  - Visible:', rightSidebar.offsetParent !== null);
                            console.log('  - Bounding rect:', rightSidebar.getBoundingClientRect());
                        } else {
                            console.log('âŒ Right sidebar not found');
                        }

                        if (sidebarOverlay) {
                            console.log('âœ… Sidebar overlay found');
                            console.log('  - ID:', sidebarOverlay.id);
                            console.log('  - Classes:', sidebarOverlay.className);
                        } else {
                            console.log('âŒ Sidebar overlay not found');
                        }

                        if (minimizeBtn) {
                            console.log('âœ… Minimize button found');
                            console.log('  - ID:', minimizeBtn.id);
                            console.log('  - Classes:', minimizeBtn.className);
                        } else {
                            console.log('âŒ Minimize button not found');
                        }

                        // Test CSS classes and styles
                        if (rightSidebar) {
                            console.log('ðŸŽ¨ CSS Analysis:');
                            const computedStyle = window.getComputedStyle(rightSidebar);
                            console.log('  - Computed transform:', computedStyle.transform);
                            console.log('  - Computed position:', computedStyle.position);
                            console.log('  - Computed z-index:', computedStyle.zIndex);
                            console.log('  - Computed display:', computedStyle.display);
                            console.log('  - Computed visibility:', computedStyle.visibility);
                            console.log('  - Computed opacity:', computedStyle.opacity);
                        }
                    }

                    // SIDEBAR ALWAYS VISIBLE - Make sidebar visible on page load
                    (function () {
                        console.log('ðŸŽ¯ Making sidebar always visible (Google Gemini style)');

                        // Force sidebar to be visible
                        const rightSidebar = document.querySelector('.right-sidebar');
                        if (rightSidebar) {
                            rightSidebar.style.transform = 'translateX(0)';
                            rightSidebar.style.pointerEvents = 'auto';
                            rightSidebar.style.visibility = 'visible';
                            rightSidebar.style.opacity = '1';
                            rightSidebar.style.display = 'flex';
                            rightSidebar.classList.add('sidebar-open');
                            console.log('âœ… Sidebar visible on page load');
                        }

                        // Hide the toggle button since sidebar is always visible
                        const sidebarToggle = document.getElementById('sidebarToggleMobile');
                        if (sidebarToggle) {
                            sidebarToggle.style.display = 'none';
                        }
                    })();

                    // Call test function after a short delay
                    setTimeout(testSidebarToggle, 1000);
                </script>
            </div> <!-- Close main-content container -->
        </div> <!-- Close app-container -->

        <!-- Right Sidebar - Now properly positioned inside main-layout but outside app-container -->
        <div id="rightSidebar" class="right-sidebar">
            <!-- Notes Section -->
            <div class="sidebar-section">
                <div class="sidebar-header">
                    <h3 class="sidebar-title">Private Notes</h3>
                    <div class="flex items-center space-x-2">
                        <button id="addNoteBtn" class="add-btn">
                            <i class="fas fa-plus"></i>
                        </button>
                        <button id="minimizeBtn" class="minimize-btn" title="Minimize Sidebar">
                            <i class="fas fa-chevron-right"></i>
                        </button>
                    </div>
                </div>
                <div id="notesContainer">
                    <div class="empty-state">
                        <div class="empty-icon">
                            <i class="fas fa-sticky-note"></i>
                        </div>
                        <p>No notes yet. Add your first note!</p>
                    </div>
                </div>
            </div>

            <!-- Templates Section -->
            <div class="sidebar-section">
                <div class="sidebar-header">
                    <h3 class="sidebar-title">Response Templates</h3>
                    <button id="addTemplateBtn" class="add-btn">
                        <i class="fas fa-plus"></i>
                    </button>
                </div>
                <div id="templatesContainer">
                    <div class="empty-state">
                        <div class="empty-icon">
                            <i class="fas fa-file-alt"></i>
                        </div>
                        <p>No templates yet. Add your first template!</p>
                    </div>
                </div>
            </div>

            <!-- Common Documents Section -->
            <div class="sidebar-section">
                <div class="sidebar-header">
                    <h3 class="sidebar-title">Common Documents</h3>
                    <button id="addDocumentBtn" class="add-btn">
                        <i class="fas fa-plus"></i>
                    </button>
                </div>
                <div id="documentsContainer">
                    <div class="empty-state">
                        <div class="empty-icon">
                            <i class="fas fa-file-pdf"></i>
                        </div>
                        <p>No documents yet. Add your first document!</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Sidebar overlay for mobile -->
        <div id="sidebarOverlay" class="sidebar-overlay"></div>
    </div> <!-- Close main-layout -->

    <!-- Socket.IO Real-Time Reply Updates -->
    <script>
        (function () {
            // Get ticket ID from URL
            const ticketId = '{{ ticket.ticket_id }}';
            const currentUserId = '{{ session.user_id if session.user_id else "customer" }}';
            const currentUserType = '{{ "agent" if session.is_agent else "customer" }}';

            // Connect to Socket.IO server
            const socket = io();
            let typingTimeout = null;

            // DEDUPLICATION: Track processed message IDs and content hashes
            const processedReplies = new Set();

            // Initialize with existing message IDs from the DOM
            document.querySelectorAll('.message[data-reply-id]').forEach(msg => {
                const replyId = msg.dataset.replyId;
                if (replyId) processedReplies.add(replyId);
            });

            // Also create hashes of existing messages for content-based deduplication
            document.querySelectorAll('.message').forEach(msg => {
                const content = msg.querySelector('.message-content');
                const sender = msg.querySelector('.message-sender');
                if (content && sender) {
                    const hash = `${sender.textContent.trim()}:${content.textContent.trim().substring(0, 100)}`;
                    processedReplies.add(hash);
                }
            });

            console.log('[SOCKET] Initialized deduplication with', processedReplies.size, 'existing messages');

            socket.on('connect', function () {
                console.log('[SOCKET] Connected - joining ticket room:', ticketId);
                socket.emit('join_ticket', { ticket_id: ticketId });
            });

            socket.on('disconnect', function () {
                console.log('[SOCKET] Disconnected');
            });

            // Listen for new replies
            socket.on('new_reply', function (data) {
                console.log('[SOCKET] New reply received:', data);

                // ROBUST DEDUPLICATION: Check by reply_id first
                if (data.reply_id && processedReplies.has(data.reply_id)) {
                    console.log('[SOCKET] Duplicate message detected by ID, skipping');
                    return;
                }

                // Content-based deduplication as fallback
                const contentHash = `${data.sender_name}:${data.message.substring(0, 100)}`;
                if (processedReplies.has(contentHash)) {
                    console.log('[SOCKET] Duplicate message detected by content hash, skipping');
                    return;
                }

                // Mark as processed
                if (data.reply_id) processedReplies.add(data.reply_id);
                processedReplies.add(contentHash);

                // Show toast notification only if it's NOT from me
                if (data.sender_type !== currentUserType && data.sender_name !== '{{ session.name }}') {
                    showReplyToast(data.sender_name, data.message);
                }

                // Always add to conversation (deduplication logic above handles double-adds)
                addReplyToConversation(data);

                // Clear typing indicator if it exists
                removeTypingIndicator();
            });

            // Listen for typing events
            socket.on('typing', function (data) {
                // Don't show typing indicator for myself
                if (data.user_name === '{{ session.name }}') return;
                showTypingIndicator(data.user_name);
            });

            socket.on('stop_typing', function (data) {
                removeTypingIndicator();
            });

            // Listen for ticket updates (status/priority)
            socket.on('ticket_updated', function (data) {
                console.log('[SOCKET] Ticket updated:', data);
                if (data.status) updateStatusUI(data.status);
                if (data.priority) updatePriorityUI(data.priority);
            });

            // ===== NEW: Specific Status Changed =====
            socket.on('ticket_status_changed', function (data) {
                console.log('[SOCKET] Status changed:', data);
                updateStatusUI(data.new_status);
                showReplyToast('System', `Status changed to ${data.new_status} by ${data.changed_by_name}`);
            });

            // ===== NEW: Specific Priority Changed =====
            socket.on('ticket_priority_changed', function (data) {
                console.log('[SOCKET] Priority changed:', data);
                updatePriorityUI(data.new_priority);
                showReplyToast('System', `Priority changed to ${data.new_priority} by ${data.changed_by_name}`);
            });

            // ===== NEW: Technician Assigned =====
            socket.on('technician_assigned', function (data) {
                console.log('[SOCKET] Technician assigned:', data);
                updateTechnicianUI(data.technician_name);
                showReplyToast('System', `Technician ${data.technician_name} assigned by ${data.assigned_by_name}`);
            });

            // ===== NEW: Ticket Forwarded =====
            socket.on('ticket_forwarded', function (data) {
                console.log('[SOCKET] Ticket forwarded:', data);
                updateForwardedUI(data.forwarded_to_name);
                showReplyToast('System', `Ticket forwarded to ${data.forwarded_to_name} by ${data.forwarded_from_name}`);
            });

            // ===== NEW: Ticket Taken Over =====
            socket.on('ticket_taken_over', function (data) {
                console.log('[SOCKET] Ticket taken over:', data);
                updateAssignedToUI(data.taken_by_name);
                showReplyToast('System', `Ticket taken over by ${data.taken_by_name}`);
            });

            // ===== NEW: Ticket Referred to Tech Director =====
            socket.on('ticket_referred', function (data) {
                console.log('[SOCKET] Ticket referred:', data);
                showReplyToast('System', `Ticket referred to Technical Director by ${data.referred_by_name}`);
            });

            // ===== UI Update Helper Functions =====
            function updateStatusUI(newStatus) {
                // Update status badge in header
                const statusBadge = document.querySelector('.status-badge, [data-status]');
                if (statusBadge) {
                    statusBadge.textContent = newStatus;
                    statusBadge.className = statusBadge.className.replace(/status-\w+/g, '');
                    statusBadge.classList.add(`status-${newStatus.toLowerCase().replace(/\s+/g, '-')}`);
                }

                // Update status dropdown if exists
                const statusDropdown = document.getElementById('statusDropdown');
                if (statusDropdown) statusDropdown.value = newStatus;
            }

            function updatePriorityUI(newPriority) {
                // Update priority badge in header
                const priorityBadge = document.querySelector('.priority-badge, [data-priority]');
                if (priorityBadge) {
                    priorityBadge.textContent = newPriority;
                    priorityBadge.className = priorityBadge.className.replace(/priority-\w+|badge-\w+/g, '');
                    const priorityClass = newPriority === 'Urgent' ? 'badge-urgent' :
                        newPriority === 'High' ? 'badge-fast' :
                            newPriority === 'Medium' ? 'badge-medium' : 'badge-low';
                    priorityBadge.classList.add('priority-badge', priorityClass);
                }

                // Update priority dropdown if exists
                const priorityDropdown = document.getElementById('priorityDropdown');
                if (priorityDropdown) priorityDropdown.value = newPriority;
            }

            function updateTechnicianUI(technicianName) {
                // Update technician display
                const technicianEl = document.querySelector('[data-technician], .assigned-technician');
                if (technicianEl) technicianEl.textContent = technicianName;

                // Update technician dropdown if exists
                const techDropdown = document.getElementById('technicianDropdown');
                if (techDropdown) {
                    const option = Array.from(techDropdown.options).find(o => o.text.includes(technicianName));
                    if (option) techDropdown.value = option.value;
                }
            }

            function updateForwardedUI(forwardedToName) {
                // Update or add forwarded badge
                let forwardedBadge = document.querySelector('.forwarded-badge');
                if (!forwardedBadge) {
                    forwardedBadge = document.createElement('span');
                    forwardedBadge.className = 'forwarded-badge status-badge';
                    forwardedBadge.style.cssText = 'background: rgba(59, 130, 246, 0.15); color: #3b82f6; border: 1px solid rgba(59, 130, 246, 0.25);';
                    const badgesContainer = document.querySelector('.ticket-badges, .flex.gap-2');
                    if (badgesContainer) badgesContainer.appendChild(forwardedBadge);
                }
                forwardedBadge.innerHTML = `<i class="fas fa-share mr-1"></i>Forwarded to ${forwardedToName}`;
            }

            function updateAssignedToUI(assignedName) {
                // Update assigned to display
                const assignedEl = document.querySelector('[data-assigned-to], .assigned-to');
                if (assignedEl) assignedEl.textContent = assignedName;
            }

            // Emit typing events
            const responseTextarea = document.getElementById('response');
            if (responseTextarea) {
                responseTextarea.addEventListener('input', function () {
                    socket.emit('typing', {
                        ticket_id: ticketId,
                        user_name: '{{ session.name or "User" }}',
                        user_id: currentUserId
                    });

                    if (typingTimeout) clearTimeout(typingTimeout);
                    typingTimeout = setTimeout(function () {
                        socket.emit('stop_typing', {
                            ticket_id: ticketId,
                            user_id: currentUserId
                        });
                    }, 2000);
                });
            }

            // Toast notification for new replies
            function showReplyToast(sender, message) {
                let container = document.getElementById('toast-container');
                if (!container) {
                    container = document.createElement('div');
                    container.id = 'toast-container';
                    container.style.cssText = 'position: fixed; top: 20px; right: 20px; z-index: 9999; display: flex; flex-direction: column; gap: 10px;';
                    document.body.appendChild(container);
                }

                const toast = document.createElement('div');
                toast.style.cssText = `
                background: linear-gradient(135deg, rgba(30, 30, 40, 0.95), rgba(40, 40, 55, 0.95));
                backdrop-filter: blur(10px);
                border: 1px solid rgba(34, 197, 94, 0.4);
                border-radius: 12px;
                padding: 16px 20px;
                min-width: 300px;
                max-width: 400px;
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
                animation: slideIn 0.3s ease-out;
            `;

                toast.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 12px;">
                    <i class="fas fa-comment" style="color: #22c55e; font-size: 20px;"></i>
                    <div style="flex: 1;">
                        <div style="font-weight: 600; color: #fff; margin-bottom: 4px;">New Reply from ${sender}</div>
                        <div style="color: rgba(255,255,255,0.7); font-size: 13px;">${message.substring(0, 100)}${message.length > 100 ? '...' : ''}</div>
                    </div>
                    <button onclick="this.parentElement.parentElement.remove()" style="background: none; border: none; color: rgba(255,255,255,0.4); cursor: pointer;"><i class="fas fa-times"></i></button>
                </div>
            `;

                container.appendChild(toast);
                setTimeout(() => toast.remove(), 5000);
            }

            // Add reply to conversation dynamically
            function addReplyToConversation(data) {
                const container = document.querySelector('.conversation-container');
                if (!container) return;

                const isCustomer = data.sender_type !== 'agent';
                const msgClass = isCustomer ? 'customer-message' : 'support-message';
                const iconClass = isCustomer ? 'fas fa-user-circle customer-icon' : 'fas fa-headset support-icon';
                const senderName = data.sender_name || (isCustomer ? '{{ ticket.name }}' : 'Support Team');

                const msgDiv = document.createElement('div');
                msgDiv.className = `message ${msgClass}`;
                msgDiv.style.animation = 'slideIn 0.3s ease-out';

                // Basic structure matching server-side template
                msgDiv.innerHTML = `
                    <div class="message-header">
                        <span class="font-medium flex items-center">
                            <i class="${iconClass}"></i> ${senderName}
                        </span>
                        <span class="message-time">Just now</span>
                    </div>
                    <div class="reply-message-box">
                        <div class="message-content">${data.message}</div>
                    </div>
                `;

                // Handle attachments if present (simplified text representation for now or rudimentary HTML)
                if (data.attachments && data.attachments.length > 0) {
                    // TODO: Build attachment HTML dynamically if needed
                    // For now just appending a note
                    const attDiv = document.createElement('div');
                    attDiv.className = 'mt-2 text-xs text-gray-500';
                    attDiv.innerHTML = `<i class="fas fa-paperclip"></i> ${data.attachments.length} Attachment(s) (Reload to view)`;
                    msgDiv.querySelector('.reply-message-box').appendChild(attDiv);
                }

                container.appendChild(msgDiv);
                window.scrollTo(0, document.body.scrollHeight);
            }

            // Typing Indicator
            function showTypingIndicator(username) {
                const container = document.querySelector('.conversation-container');
                if (!container) return;

                let indicator = document.getElementById('typing-indicator');
                if (!indicator) {
                    indicator = document.createElement('div');
                    indicator.id = 'typing-indicator';
                    indicator.className = 'message customer-message'; // Default style
                    indicator.style.opacity = '0.7';
                    indicator.innerHTML = `
                        <div class="message-header">
                            <span class="font-medium text-xs text-gray-400">
                                <i class="fas fa-keyboard mr-1 animate-pulse"></i> ${username} is typing...
                            </span>
                        </div>
                    `;
                    container.appendChild(indicator);
                    container.scrollTop = container.scrollHeight;
                }
            }

            function removeTypingIndicator() {
                const indicator = document.getElementById('typing-indicator');
                if (indicator) indicator.remove();
            }

            // Update Status UI
            function updateStatusUI(status) {
                const statusBadge = document.getElementById('statusBadge');
                if (statusBadge) {
                    statusBadge.textContent = status;

                    // Helper to get color class based on status
                    const getStatusColor = (s) => {
                        s = s.toLowerCase();
                        if (s.includes('open')) return 'status-open';
                        if (s.includes('pending')) return 'status-pending';
                        if (s.includes('closed') || s.includes('solved')) return 'status-closed';
                        return 'status-new'; // default
                    };

                    // Remove only status-* color classes, NOT status-badge or other utilities
                    statusBadge.className = statusBadge.className.replace(/\bstatus-(?!badge)[\w-]+\b/g, '');
                    // Add new class and ensure status-badge is present
                    statusBadge.classList.add(getStatusColor(status));
                    statusBadge.classList.add('status-badge');
                    // Add new class
                    statusBadge.classList.add(getStatusColor(status));

                    // Also update the dropdown text if it exists
                    const currentStatusDisplay = document.getElementById('currentStatusDisplay');
                    if (currentStatusDisplay) currentStatusDisplay.textContent = status;
                }
            }

            // Expose globally
            window.toggleMessage = function (index) {
                const content = document.getElementById(`message-content-${index}`);
                const btn = document.getElementById(`toggle-btn-${index}`);

                if (!content || !btn) return;

                if (content.classList.contains('line-clamp-3')) {
                    // Expand â€“ remove clamp and show all text
                    content.classList.remove('line-clamp-3');
                    content.style.webkitLineClamp = 'unset';
                    content.style.lineClamp = 'unset';
                    content.style.display = 'block';
                    content.style.overflow = 'visible';
                    btn.innerHTML = '<i class="fas fa-chevron-up mr-1"></i> Show Less';
                } else {
                    // Collapse â€“ re-apply clamp
                    content.classList.add('line-clamp-3');
                    content.style.webkitLineClamp = '3';
                    content.style.lineClamp = '3';
                    content.style.display = '-webkit-box';
                    content.style.overflow = 'hidden';
                    btn.innerHTML = '<i class="fas fa-chevron-down mr-1"></i> Read More';
                }
            };



            // Add CSS animation
            if (!document.getElementById('socket-styles')) {
                const style = document.createElement('style');
                style.id = 'socket-styles';
                style.textContent = `
                @keyframes slideIn {
                    from { transform: translateX(100%); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
            `;
                document.head.appendChild(style);
            }
        })();
    </script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const editor = document.getElementById('response_editor');
            const menu = document.getElementById('mentionMenu');

            if (!editor || !menu) return;

            let isMentioning = false;
            let mentionStartIndex = 0;

            // We can show the menu based on the cursor position
            function updateMenuPosition() {
                // Position relative to the editor
                const editorRect = editor.getBoundingClientRect();

                // Simplified positioning logic that works reliably
                menu.style.left = '16px';
                menu.style.bottom = '100%';
                menu.style.top = 'auto'; // override default top
                menu.style.marginBottom = '8px';

                menu.classList.remove('hidden');
                console.log("Showing mention menu!");
            }

            // Capture input for @
            editor.addEventListener('input', (e) => {
                const selection = window.getSelection();
                if (!selection.rangeCount) return;

                const range = selection.getRangeAt(0);

                // Get text before cursor
                let textBeforeCursor = '';
                if (range.startContainer.nodeType === Node.TEXT_NODE) {
                    textBeforeCursor = range.startContainer.textContent.substring(0, range.startOffset);
                } else if (range.startContainer === editor) {
                    textBeforeCursor = editor.textContent;
                }

                console.log("Text before cursor: '" + textBeforeCursor + "'");

                // Check if we just typed `@` or are currently typing a mention
                const match = textBeforeCursor.match(/(?:^|\s)(@\w*)$/);

                if (match) {
                    isMentioning = true;
                    mentionStartIndex = range.startOffset - match[1].length;
                    updateMenuPosition();
                } else {
                    isMentioning = false;
                    menu.classList.add('hidden');
                }
            });

            // Handle arrow keys and Enter when menu is open
            editor.addEventListener('keydown', (e) => {
                if (!isMentioning) return;

                if (e.key === 'Escape') {
                    isMentioning = false;
                    menu.classList.add('hidden');
                }
            });

            // Handle clicking a mention item
            document.querySelectorAll('.mention-item').forEach(item => {
                item.addEventListener('mousedown', (e) => {
                    e.preventDefault(); // Prevents the editor from losing focus
                    e.stopPropagation();
                    insertMention(item.getAttribute('data-value'), item.getAttribute('data-id'));
                });
            });

            function insertMention(value, id) {
                const selection = window.getSelection();
                if (!selection.rangeCount) return;

                const range = selection.getRangeAt(0);

                // Ensure we are working with text node
                if (range.startContainer.nodeType === Node.TEXT_NODE) {
                    let text = range.startContainer.textContent;

                    // Find the @ typed
                    const beforeCursor = text.substring(0, range.startOffset);
                    const afterCursor = text.substring(range.startOffset);
                    const textParts = beforeCursor.split(/(?:^|\s)(@\w*)$/);

                    if (textParts.length >= 2) {
                        const preMentionText = textParts.slice(0, -2).join('') + (beforeCursor.match(/(?:^|\s)(@\w*)$/)[0].startsWith(' ') ? ' ' : '');

                        // Construct new nodes
                        const preNode = document.createTextNode(preMentionText);
                        const mentionBadge = document.createElement('span');
                        mentionBadge.className = 'mention-badge';
                        mentionBadge.contentEditable = 'false';
                        mentionBadge.dataset.ref = id;
                        mentionBadge.innerHTML = `<i class="fas fa-link mr-1"></i>${value}`;

                        // Add a trailing space so user can keep typing
                        const postNode = document.createTextNode('\u00A0' + afterCursor); // NBSP

                        // Replace the text node with the new elements
                        const parent = range.startContainer.parentNode;
                        parent.insertBefore(preNode, range.startContainer);
                        parent.insertBefore(mentionBadge, range.startContainer);
                        parent.insertBefore(postNode, range.startContainer);
                        parent.removeChild(range.startContainer);

                        // Move cursor right after the badge and the space
                        const newRange = document.createRange();
                        newRange.setStart(postNode, 1);
                        newRange.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(newRange);
                    }
                }

                // Hide menu
                isMentioning = false;
                menu.classList.add('hidden');

                // Trigger manual input so localstorage updates
                editor.dispatchEvent(new Event('input', { bubbles: true }));
            }

            // Close menu when clicking outside
            document.addEventListener('click', (e) => {
                if (!menu.contains(e.target) && e.target !== editor) {
                    isMentioning = false;
                    menu.classList.add('hidden');
                }
            });
        });
    </script>
